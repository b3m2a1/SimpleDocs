(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ProcessRun::usage=
	"RunProcess wrapper";
ProcessStart::usage="";
ProcessRead::usage="Reads from a process object";


TerminalRun::usage=
	"Runs a command with a GUI command visualizer";
TerminalRunNonBlocking::usage=
	"A non-blocking version of TerminalRun";
TerminalShell::usage=
	"Creates an interactive shell for running processes";


Begin["`Private`"];


ProcessRun::pnfd="Program `` not found. 
$PATH = ``
$PWD = ``";
ProcessRun::fail="Process failed to run: ``"; 
ProcessRun::err="\nError in command \"``\":\n``";
ProcessRun~SetAttributes~HoldRest;


Options[ProcessRun]=
	Join[Options[RunProcess],{
		"ErrorHandler"->Automatic,
		"ParseFunction"->Identity
		}];
ProcessRun[cmds:{__},
	errorMessage:Except[_?OptionQ|_FilterRules]:ProcessRun::err,
	ops:OptionsPattern[]
	]:=
	Block[{capturedMessages={}},
		With[{r=
			GeneralUtilities`WithMessageHandler[
				RunProcess[cmds,
					FilterRules[{ops},Options@RunProcess]
					],
				AppendTo[capturedMessages,#]&
				],
			parseFunction=
				OptionValue["ParseFunction"],
			errorHander=
				Replace[OptionValue["ErrorHandler"],
					Automatic->
						Function[Null,
							Message[#,
								StringJoin@Riffle[cmds," "],
								#2
								],
							HoldFirst
							]
					]
			},
			If[r=!=$Failed,
				If[r["StandardError"]!="",
					errorHander[errorMessage,r["StandardError"]]
					];
				parseFunction@Replace[
					StringTrim@r["StandardOutput"],
					""->Null
					],
				Message[ProcessRun::fail,
					StringJoin@Riffle[
						Replace[cmds,
							(k_->v_):>
								(ToString@k<>"=="<>ToString@v),
							1],
						" "]
					];
				Replace[capturedMessages,
					Failure[RunProcess,<|
						"MessageTemplate":>
							RunProcess::pnfd,
						"MessageParameters" -> pars_
						|>]:>(
							Message[ProcessRun::pnfd,
								Sequence@@Join[pars,
									StringTrim@
										RunProcess[{$SystemShell,"-c","echo $PATH"},"StandardOutput"],
									StringTrim@
										RunProcess[{$SystemShell,"-c","echo $PWD"},"StandardOutput"]
									]
								];
							),
					1];
				$Failed
				]
			]
		];
ProcessRun[s_String,
	errorMessage:_MessageName:ProcessRun::err,
	ops:OptionsPattern[]]:=
	ProcessRun[{s},errorMessage,ops];


ProcessStart::pnfd="Program `` not found. 
$PATH = ``
$PWD = ``";
ProcessStart::fail="Process failed to run: ``";


Options[ProcessStart]=
	Options[StartProcess];
ProcessStart::usage=
	StringJoin[ProcessStart::usage,
		"\n",
		"Wrapper to StartProcess that provides more descriptive failure errors"
		];
ProcessStart[cmds:{__},
	ops:OptionsPattern[]
	]:=
	Block[{capturedMessages={}},
		With[{r=
			GeneralUtilities`WithMessageHandler[
				StartProcess[cmds,
					FilterRules[{ops},Options@StartProcess]
					],
				AppendTo[capturedMessages,#]&
				]
			},
			If[r=!=$Failed,
				r,
				Message[ProcessStart::fail,
					StringJoin@Riffle[
						Replace[cmds,
							(k_->v_):>
								(ToString@k<>"=="<>ToString@v),
							1],
						" "]
					];
				Replace[capturedMessages,
					Failure[RunProcess,<|
						"MessageTemplate":>
							ProcessStart::pnfd,
						"MessageParameters" -> pars_
						|>]:>(
							Message[ProcessStart::pnfd,
								Sequence@@Join[pars,
									StringTrim@
										RunProcess[{$SystemShell,"-c","echo $PATH"},"StandardOutput"],
									StringTrim@
										RunProcess[{$SystemShell,"-c","echo $PWD"},"StandardOutput"]
									]
								];
							),
					1];
				$Failed
				]
			]
		];
ProcessStart::usage=
	StringJoin[ProcessStart::usage,
		"\n",
		"Single string version of ProcessStart"
		];
ProcessStart[s_String,
	ops:OptionsPattern[]]:=
	ProcessStart[{s},ops];


ProcessRead::err=
	"\nError in process:\n``";
Options[ProcessRead]={
	"ErrorHandler"->
		Automatic,
	"ParseFunction"->
		Identity
	};
ProcessRead~SetAttributes~HoldRest;
ProcessRead[procObj_,
	errorMessage:Except[_?OptionQ|_FilterRules]:ProcessRead::err,
	ops:OptionsPattern[]
	]:=
	With[{
		out=
			ReadString[ProcessConnection[procObj,"StandardOutput"],
				EndOfBuffer],
		err=
			ReadString[ProcessConnection[procObj,"StandardError"],
				EndOfBuffer],
		handler=
			Replace[OptionValue["ErrorHandler"],
				Automatic:>
					Message
				],
		parse=
			OptionValue["ParseFunction"]
		},
		If[err!="",
			handler[errorMessage,If[StringQ@err,StringTrim@err,err]]
			];
		If[out=!="",
			With[{o=If[StringQ@out,StringTrim[out],out]},
				parse[o]
				]
			]
		];


terminalRead[p_,readVar_]:=
	Block[{$terminalProcessKillFlag=False},
		ProcessRead[p,
			"ParseFunction"->
				Replace[{
					s_String?(StringLength@#>0&):>(
						AppendTo[readVar,s]
						),
					EndOfFile:>($terminalProcessKillFlag=True)
					}],
			"ErrorHandler"->
				Replace[{
					s_String?(StringLength@#>0&):>AppendTo[readVar,s],
					EndOfFile:>($terminalProcessKillFlag=True)
					}]
			];
		If[$terminalProcessKillFlag,KillProcess@p]
		];
terminalRead~SetAttributes~HoldRest;


Options[TerminalRun]=
	Join[
		Options@StartProcess,{
		"PollTime"->Automatic,
		"Title"->Automatic
		}];
TerminalRun[cmd_,o:OptionsPattern[]]:=
	With[{
		p=
			ProcessStart[cmd,
				FilterRules[{o},Options@StartProcess]
				],
		poll=
			Replace[OptionValue@"PollTime",
				Except[_?NumericQ]:>.1
				],
		title=
			Replace[OptionValue@"Title",
				Automatic:>StringJoin@Riffle[
					Replace[Flatten@{cmd},{
						r:(_Rule|_RuleDelayed):>
							"-"<>ToLowerCase[ToString@First@r]<>
								"="<>ToString@Last@r,
						e:Except[_String]:>
							ToString@e
						},
						1]," "]
				]},
		If[MatchQ[p,_ProcessObject],
			Block[{
				$terminalDownloadStrings={StringJoin@{title,"\n"}}
				},
				Pause[.001];
				terminalRead[p,$terminalDownloadStrings];
				Monitor[
					While[ProcessStatus@p==="Running",
						terminalRead[p,$terminalDownloadStrings];
						Pause[poll];
						],
					PaneWindow[
						Dynamic[
							StringJoin@$terminalDownloadStrings,
							TrackedSymbols:>{}
							],
						WindowTitle->title,
						Scrollbars->Automatic,
						ScrollPosition->{0,Dynamic@25*Length@$terminalDownloadStrings}
						]
					];
				StringJoin@$terminalDownloadStrings
				],
			$Failed
			]
		];


Options[TerminalRunNonBlocking]=
	DeleteDuplicatesBy[First]@Join[{
		"PollTime"->1
		},
		Options@TerminalRun
		];
TerminalRunNonBlocking[cmd_,ops:OptionsPattern[]]:=
	With[{
		p=
			ProcessStart[cmd,
				FilterRules[{ops},Options@ProcessStart]
				],
		title=
			Replace[OptionValue@"Title",
				Automatic:>StringJoin@Riffle[
					Replace[Flatten@{cmd},{
						r:(_Rule|_RuleDelayed):>
							"-"<>ToLowerCase[ToString@First@r]<>
								"="<>ToString@Last@r,
						e:Except[_String]:>
							ToString@e
						},
						1]," "]
				],
		s=Unique@$terminalDownloadStrings$},
		s={title,"\n"};
		Interpretation[
			PaneWindow[
				Dynamic[
					s;
					Quiet[terminalRead[p,s];
						If[Length@$MessageList>0,
							FrontEnd`SetOptions[EvaluationBox[],
								UpdateInterval->\[Infinity]
								]
							]
						];
				StringJoin@s,
				Evaluate@
					Replace[OptionValue["PollTime"],{
						n_?NumericQ:>{
							TrackedSymbols:>{},
							UpdateInterval->n
							},
						_:>Sequence@@{
							TrackedSymbols:>{s}
							}
						}]
				],
			WindowTitle->
				title,
			CloseButton->
				InterpretationBox,
			ImageSize->Dynamic,
			Scrollbars->Automatic,
			ScrollPosition->{
				0,
				Dynamic@25*Length@s
				}
			],
			StringJoin@s
			]
		];


Options[TerminalShell]=
	Options[TerminalRunNonBlocking];
TerminalShell[startcmd:Except[_?OptionQ]:Automatic,ops:OptionsPattern[]]:=
	With[{
		termStrings=Unique@termStrings,
		termInput=Unique@termInput,
		cmd=Replace[startcmd,Automatic->$SystemShell],
		imgSize=Unique@imgSize,
		inputFieldHeight=25,
		lineHeight=22
		},
		imgSize={400,400/GoldenRatio};
		With[{
			p=
				ProcessStart[cmd,
					FilterRules[{ops},Options@ProcessStart]
					],
			title=
				Replace[OptionValue@"Title",
					Automatic:>StringJoin@Riffle[
						Replace[Flatten@{cmd},{
							r:(_Rule|_RuleDelayed):>
								"-"<>ToLowerCase[ToString@First@r]<>
									"="<>ToString@Last@r,
							e:Except[_String]:>
								ToString@e
							},
							1]," "]
					]
			},
			termStrings={">> "<>title};
			Interpretation[
				PaneWindow[
					Dynamic[
						Quiet[terminalRead[p,termStrings];
							If[Length@$MessageList>0,
								FrontEnd`SetOptions[EvaluationBox[],
									UpdateInterval->\[Infinity]
									]
								]
							];
						Column[{
							Pane[
								StringJoin@Riffle[termStrings,"\n"],
								Dynamic[imgSize-{0,inputFieldHeight},
									imgSize=(#+{0,inputFieldHeight});&],
								Scrollbars->True,
								ScrollPosition->
									{
										0,
										Dynamic[lineHeight*Length@termStrings]
										}
								],
							termInput="";
							EventHandler[
								InputField[Dynamic@termInput,
									String,
									ImageSize->Dynamic[ReplacePart[imgSize,2->inputFieldHeight]]],
								"ReturnKeyDown":>
									With[{in=termInput},
										termInput="";
										AppendTo[termStrings,">> "<>in];
										WriteLine[p,in];
										Pause[.05];
										terminalRead[p,termStrings]
										]
								]
							},
							Spacings->0,
							Alignment->{
								{Left},
								{Top,Bottom}
								}
							],
					Evaluate@
						Replace[OptionValue["PollTime"],{
							n_?NumericQ:>{
								TrackedSymbols:>{},
								UpdateInterval->n
								},
							_:>Sequence@@{
								TrackedSymbols:>{termStrings}
								}
							}]
					],
				WindowTitle->
					title,
				CloseButton->
					InterpretationBox,
				ButtonBar:>
					{
						"Restart":>
							KillProcess[p],
						"Kill":>
							KillProcess[p]
						},
				Scrollbars->False,
				ImageSize->
					{
						Dynamic[{First@imgSize,Automatic}],
						Dynamic[imgSize]
						},
				Appearance->Automatic
				],
				StringJoin@Riffle[termStrings,"\n"]
				]
			]
		];


End[];



