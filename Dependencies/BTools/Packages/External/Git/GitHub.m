(* ::Package:: *)

(* Autogenerated Package *)

$GitHubUsername::usage=
  "The user's github username";
$GitHubPassword::usage=
  "The user's github password";
FormatGitHubPath::usage="";
GitHubPath::usage=
  "Represents a github path";
GitHubPathParse::usage=
  "Parses a GitHubPath from a string";
GitHubRepoQ::usage=
  "Returns if the path could be a github repo";
GitHubReleaseQ::usage=
  "Returns if the path could be a GitHub release";
GitHubPathQ::usage="";
GitHubCreate::usage="";
GitHubDelete::usage="";
GitHubDeployments::usage="";
GitHubCreateRelease::usage="";
GitHubEditRelease::usage="";
GitHubDeleteRelease::usage="";
GitHubUploadReleaseAsset::usage="";
GitHubGetReleaseAsset::usage="";
GitHubEditReleaseAsset::usage="";
GitHubDeleteReleaseAsset::usage="";
GitHubReleases::usage="";
GitHubRepositories::usage="";
$GitHubActions::usage=
  "A collection of known calls for the GitHub function";
GitHubQuery::usage="Makes an HTTPRequest to GitHub";
GitHubImport::usage=
  "Imports and converts GitHub JSON";


Begin["`Private`"];


(* ::Subsection:: *)
(*Basics*)



(* ::Subsubsection::Closed:: *)
(*Actions*)



$GitHubActions=<||>


(* ::Subsubsection::Closed:: *)
(*CurrentUser*)



GitHubGetCurrentUser[]:=
  $GitHubUsername


$GitHubActions["CurrentUser"]=
  GitHubGetCurrentUser


(* ::Subsubsection::Closed:: *)
(*GetPassword*)



GitHubGetPassword[]:=
  $GitHubPassword


$GitHubActions["Password"]=
  GitHubGetPassword


(* ::Subsubsection::Closed:: *)
(*KeyChain*)



If[Length@OwnValues[$GitHubUseKeychain]==0,
  $GitHubUseKeychain:=
    TrueQ@Lookup[$GitHubConfig, "UseKeychain", False]
  ];


(*GitHubSetUseKeychain[state_]:=
	$GitHubUseKeychain=TrueQ[state];
GitHubClearUseKeychain[state_]:=
	$GitHubUseKeychain:=
		TrueQ@Lookup[$GitHubConfig, "UseKeychain", False];*)


(* ::Subsubsection::Closed:: *)
(*$GitHubConfig*)



If[Not@ValueQ@$GitHubConfig,
  $GitHubConfig:=
    Replace[
      Do[
        With[{f=PackageFilePath["Private", "Config", d]},
          If[FileExistsQ@f,
            Return[
              $GitHubConfig=
                Replace[Quiet@Import@f,
                  { 
                    o_?OptionQ:>Association@o,
                    _-><||>
                    }
                  ]
                ];
            Break[]
            ]
          ],
        {d,
          {
            "GitHubConfig.m",
            "GitHubConfig.wl"
            }
          }
        ],
      Null-><||>
      ]
  ]


$GitHubConfig=
  Merge[
    {
      $GitHubConfig,
      "EncodePassword"->False,
      "UseKeychain"->False,
      "CachePassword"->True,
      "LockPasswordCache"->False
      },
    First
    ];


(* ::Subsubsection::Closed:: *)
(*GetConfig*)



$GitHubActions["GetConfig"]=GitHubGetConfig;


GitHubGetConfig[k_]:=
  Lookup[$GitHubConfig, k];
GitHubGetConfig[]:=$GitHubConfig


(* ::Subsubsection::Closed:: *)
(*SetConfig*)



$GitHubActions["SetConfig"]=GitHubSetConfig;


GitHubSetConfig//Clear


GitHubSetConfig[o_?(OptionQ)]:=
  AssociateTo[$GitHubConfig, o];
GitHubSetConfig[k_, v_]:=
  GitHubSetConfig[k->v];


(* ::Subsubsection::Closed:: *)
(*LockPasswordCache*)



$GitHubAction["LockPasswordCache"]=
  GitHubLockPasswordCache;


GitHubLockPasswordCache[]:=
  SetAttributes[gitHubPasswordCache, {Locked, ReadProtected}];


(* ::Subsubsection::Closed:: *)
(*$GitHubUsername*)



GitHubGetDefaultUsername[]:=
  Replace[
    If[$GitHubUseKeychain, $GitHubKCUsername, None],
    Except[_String]:>
      Replace[$GitHubConfig["Username"],
        Except[_String?StringQ]:>
          GitHubSetUsernameAndPassword[
            "", 
            ""
            ][[1]]
        ]
    ]


If[Length[OwnValues@$GitHubUsername]===0,
  $GitHubUsername:=
    GitHubGetDefaultUsername[]
  ];


$GitHubKCUsername:=
  KeychainGet[{"AccountData", "GitHub", "Username"}, True]


(* ::Subsubsection::Closed:: *)
(*$GitHubEncodePassword*)



$GitHubEncodePassword:=
  TrueQ@$GitHubConfig["EncodePassword"];


(* ::Subsubsection::Closed:: *)
(*$GitHubPassword*)



$GitHubStorePassword:=
  Lookup[$GitHubConfig, 
    "CachePassword", 
    $GitHubConfig["CachePassword"]=True
    ]


GitHubPasswordCacheLookup[s_, def_:$Failed]:=
  Replace[
    gitHubPasswordCache[s],
    Except[_String]|"":>def
    ];
GitHubPasswordCacheLookup~SetAttributes~HoldRest


GitHubPassword[s_String]:=
  Module[
    {
      base=
        GitHubPasswordCacheLookup[s,
          If[$GitHubUseKeychain, KeychainGet[{"github.com",  s}, False]]
          ],
      res
      },
    If[StringQ@base,
      base,
      Which[
        $GitHubUseKeychain&&$GitHubStorePassword,
          KeychainGet[{"github.com",  s}, True],
        $GitHubStorePassword,
          (* Create an auth dialog for the found username *)
          res=
            AuthDialog[
              "",
              None,
              {{"github.com", Automatic}, s}
              ];
          If[AssociationQ[res]&&StringQ@res["github.com"][[2]],
            gitHubPasswordCache[s]=
              res["github.com"][[2]],
            gitHubPasswordCache[s]=$Failed
            ];
          gitHubPasswordCache[s],
        True,
          res=
            AuthDialog[
              "",
              None,
              {{"github.com", Automatic}, s}
              ];
          If[AssociationQ[res]&&StringQ@res["github.com"][[2]],
            res["github.com"][[2]],
            $Failed
            ]
        ]
      ]
    ];
GitHubPassword[Optional[Automatic,Automatic]]:=
  GitHubPassword[$GitHubUsername];
Clear@$GitHubPassword;
$GitHubPassword:=
  GitHubPassword[Automatic];


(*If[ValueQ@$GitHubUsername&&!KeyMemberQ[$gitHubPassCache,$GitHubUsername],
	$gitHubPassCache[$GitHubUsername]:=
		Do[
			With[{f=
				FileNameJoin@{
					$PackageDirectory,
					"Private",
					d}
				},
				If[FileExistsQ@f,
					Replace[Import@f,
						s_String:>
							($gitHubPassCache[$GitHubUsername]=s);
						];
					Return[True]
					]
				],
			{d,
				{
					"GitHubPassword.m",
					"GitHubPassword.wl"
					}
				}
			]
	];*)


(* ::Subsubsection::Closed:: *)
(*$GitHubSSHConnected*)



$GitHubSSHConnected:=
  ($GitHubSSHConnected=
    Quiet[processRunDupe[{"ssh","-T","git@github.com"}];
      Length@$MessageList===0
      ]
    );


(* ::Subsubsection::Closed:: *)
(*$GitHubAuthorizeRequests*)



If[Length@OwnValues[$GitHubAuthorizeRequests]==0,
  $GitHubAuthorizeRequests:=
    TrueQ@Lookup[$GitHubConfig, "AuthorizeRequests", False]
  ];


(* ::Subsection:: *)
(*Paths*)



(* ::Subsubsection::Closed:: *)
(*GitHubPath*)



ClearAll[GitHubPath, FormatGitHubPath]


Options[GitHubPath]=
  {
    "Username"->Automatic,
    "Password"->None,
    "Branch"->"master",
    "Tree"->"tree"
    };


(* ::Subsubsubsection::Closed:: *)
(*FormatGitHubPath*)



Options[FormatGitHubPath]=
  Options[GitHubPath];
FormatGitHubPath[path___String,ops:OptionsPattern[]]:=
  URLBuild@<|
    "Scheme"->
      "https",
    "Domain"->
      "github.com",
    If[$GitHubEncodePassword||
      MatchQ[OptionValue@"Password", _String|Automatic],
      "Username"->
        Replace[OptionValue["Username"],
          {
            Automatic:>
              Replace[OptionValue@"Password",
                Automatic|_String:>$GitHubUsername
                ],
            Except[_String]->None
            }
          ],
      Nothing
      ],
    If[$GitHubEncodePassword||
      MatchQ[OptionValue@"Password",_String|Automatic],
      "Password"->
        Replace[
          Replace[OptionValue["Username"],{
            Automatic:>$GitHubUsername,
            Except[_String]->None
            }],
          s_String:>
            Replace[OptionValue["Password"],
              Automatic:>GitHubPassword[s]
              ]
          ],
      Nothing
      ],
    "Path"->
      {
        Replace[OptionValue@"Username",
          Automatic:>$GitHubUsername
          ],
        If[Length@{path}>1&&!GitHubReleaseQ@{path},
            Sequence@@Flatten@
              Insert[{path}, 
                {
                  OptionValue["Tree"], 
                  Replace[OptionValue["Branch"], None->Nothing]
                  }, 
                2
                ],
            Sequence@@{path}
            ]
        }
    |>;


(* ::Subsubsubsection::Closed:: *)
(*GitHubPath*)



GitHubPath//Clear


GitHubPath[
  repo_String, 
  t:"tree"|"raw"|"trunk", 
  branch_String, 
  p___String, 
  ops:OptionsPattern[]
  ]:=
  GitHubPath[repo,
    If[t==="trunk", branch, Sequence@@{}],
    p, 
    "Branch"->
      If[MemberQ[{"trunk"}, t],
        None,
        branch
        ],
    "Tree"->t,
    ops
    ];
(*GitHubPath[
	repo_String, 
	t:"releases", 
	p__String,
	ops:OptionsPattern[]
	]:=
	GitHubPath[repo, t, p, ops];*)
GitHubPath[
  path___String,
  ops:OptionsPattern[]
  ]/;(TrueQ@$GitHubPathFormat):=
  FormatGitHubPath[path,ops];


(* ::Subsubsubsection::Closed:: *)
(*Parsers*)



validPathStringQ=
  (
    URLParse[#, "Domain"]=="github.com"||
    (
        URLParse[#, "Scheme"]===None&&
        URLParse[#, "Domain"]===None&&
        Length@URLParse[#, "Path"]>1
      )||
    URLParse[#, "Scheme"]==="github"||
    URLParse[#, "Scheme"]==="github-release"&
    )


GitHubPath[s_String?validPathStringQ, o:OptionsPattern[]]:=
  GitHubPathParse[s, o];
GitHubPath[URL[s_String?validPathStringQ], ops:OptionsPattern[]]:=
  GitHubPathParse[s, ops];
GitHubPath[GitHubPath[p___String, o___?OptionQ], op:OptionsPattern[]]:=
  GitHubPath[p, Sequence@@DeleteDuplicatesBy[Flatten@{op, o}, First]]


(* ::Subsubsubsection::Closed:: *)
(*UpValues Stuff*)



GitHubPath/:
  Normal[GitHubPath[repos___,ops___?OptionQ]]:=
    {
      FirstCase[{ops},
        ("Username"->u_):>u,
        $GitHubUsername
        ],
      repos
      };
GitHubPath/:
  URL[GitHubPath[path___String,ops:OptionsPattern[]]]:=
    FormatGitHubPath[path,ops]


Format[g:GitHubPath[path___String,ops:OptionsPattern[]]]:=
  RawBoxes@
    BoxForm`ArrangeSummaryBox[
      "GitHubPath",
      g,
      None,
      {
        BoxForm`MakeSummaryItem[
          {
            "Path: ", 
            If[GitHubReleaseQ@{path}, {path}[[1]], URLBuild[{path}]]
            },
          StandardForm
          ],
        BoxForm`MakeSummaryItem[
          {"URL: ", 
            Hyperlink[FormatGitHubPath@@g]
            }, StandardForm]
        },
      Map[
        BoxForm`MakeSummaryItem[
          {
            Row@{#[[1]], ": "}, #[[2]]
            },
          StandardForm
          ]&,
        Prepend[
          Flatten[Normal/@{ops}],
          "Release"->GitHubReleaseQ@{path}
          ]
        ],
      StandardForm
      ]


(* ::Subsubsection::Closed:: *)
(*GitHubPathQ*)



GitHubPathQ[path:_String|_URL]:=
  With[{p=URLParse[path]},
    (
      (MatchQ[p["Scheme"],"http"|"https"|None]&&p["Domain"]==="github.com")||
      (MatchQ[p["Scheme"], ("github"|"github-release")]&&p["Domain"]===None)
      )
      &&
    Length@p["Path"]>0
    ];
GitHubPathQ[_GitHubPath]:=
  True;


(* ::Subsubsection::Closed:: *)
(*GitHubPathParse*)



GitHubPathParse//Clear


Options[GitHubPathParse]=
  Options[GitHubPath];
GitHubPathParse[s_, ops:OptionsPattern[]]:=
  GitHubPathParseRaw[
    Which[
      URLParse[s, "Scheme"]==="github-release",
        URLBuild@<|
          "Scheme"->"github",
          "Path"->
            Replace[URLParse[s, "Path"],
              {
                r:{_, _, "releases", "latest"}:>r,
                {a_, b_, "releases"}:>{a, b, "releases", "latest"},
                {a_, b_}:>{a, b, "releases", "latest"},
                {a_, b_, "tag", c_}:>{a, b, "releases", "tag", c},
                {a_, b_, c_}:>{a, b, "releases", "tag", c}
                }
              ]
          |>,
      URLParse[s, "Scheme"]==="github"||
        URLParse[s, "Domain"]==="github.com",
        s,
      True,
        "github:"<>s
      ],
  ops
  ]


GitHubPathParseRaw[path:_String|_URL, o:OptionsPattern[]]:=
  If[GitHubPathQ[path],
    Replace[
      DeleteCases[""]@
        URLParse[path, "Path"],
      {
        {user_, parts___}:>
          GitHubPath[parts, "Username"->user, o]
        }
      ],
    $Failed
    ];


(* ::Subsubsection::Closed:: *)
(*GitHubRepoParse*)



GitHubRepoParse[path:_String|_URL]:=
  If[GitHubPathQ[path],
    Replace[
      DeleteCases[""]@
        URLParse[path,"Path"],{
      {"repos",user_,parts__}|
      {user_,parts__,"releases"|"deployments"}|
      {user_,parts__,"releases"|"deployments","tag",___}:>
        GitHubPath[parts,"Username"->user]
      }],
    $Failed
    ];


(* ::Subsubsection::Closed:: *)
(*GitHubRepoQ*)



iGitHubRepoQ[path:_String|_URL]:=
  GitHubPathQ[path]&&
  With[{p=URLParse[path]},
    !MatchQ[p["Path"],
      {"repos", __}|
      {__,"releases", ___}
      ]
    ];
GitHubRepoQ[p:GitHubPath[___String,___?OptionQ]]:=
  iGitHubRepoQ[URL@p]
GitHubRepoQ[path:_String|_URL]:=
  GitHubRepoQ[GitHubPath@path];
GitHubRepoQ[_]:=False


(* ::Subsubsection::Closed:: *)
(*GitHubReleaseQ*)



GitHubReleaseQ//Clear


GitHubReleaseQ[{p__String}]:=
  MatchQ[{p},
    {__, "releases", "latest"}|
    {__, "releases", "tag", _}
    ];
GitHubReleaseQ[GitHubPath[p__String,___?OptionQ]]:=
  GitHubReleaseQ[{p}];
GitHubReleaseQ[path:_String|_URL]:=
  If[GitHubPathQ@path,
    Replace[GitHubPath[path],{
      g_GitHubPath:>
        GitHubReleaseQ@g,
      _->False
      }],
    False
    ];
GitHubReleaseQ[___]:=False;


(* ::Subsection:: *)
(*Queries*)



(* ::Subsubsection::Closed:: *)
(*GitHubQuery*)



(* ::Subsubsubsection::Closed:: *)
(*GitHubQueryAttachAuth*)



GitHubQueryAttachAuth[headers_]:=
  ReplacePart[headers,
    {
      "Headers":>
        ReplaceAll[headers["Headers"],
          {
            ("Authorization"->Automatic):>
              ("Authorization"->GitHubAuthHeader[] ),
            ("Authorization"->{u__}):>
              ("Authorization"->GitHubAuthHeader[u])
            }
          ],
      "Username":>
        Replace[
          headers["Username"],
          Automatic:>
            Replace[$GitHubUsername,
              Except[_String?(StringLength[#]>0&)]:>
                GitHubSetUsernameAndPassword[
                  Automatic, 
                  Lookup[headers, "Password", $GitHubPassword]
                  ]
              ]
          ],
      "Password":>
        Replace[
          headers["Password"],
          Automatic:>
            Replace[$GitHubPassword,
              Except[_String?(StringLength[#]>0&)]:>
                GitHubSetUsernameAndPassword[
                  Lookup[headers, "Username", $GitHubPassword], 
                  Automatic
                  ]
              ]
          ]
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*GitHubQueryPrepBody*)



$GitHubBodyFormat="Base64";


GitHubQueryPrepBody[headers_]:=
  If[headers["Body"]==={},
    KeyDrop[headers, "Body"],
    ReplacePart[headers,
      "Body":>
        Replace[
          o_?OptionQ:>
            ExportString[o, "JSON"]
          ]@
        ReplaceAll[
          headers["Body"],
          {
            File[f_]:>
              Switch[$GitHubBodyFormat, 
                "Binary",
                  ReadByteArray[f],
                "Base64",
                  Developer`EncodeBase64[ReadString[f]],
                _,
                  ReadString[f]
                ]
            }
          ]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*GitHubQuery*)



$GitHubQueryBase=
  <|
    "Scheme"->"https",
    "Domain"->"api.github.com"
    |>;


GitHubQuery[
  path:_?(MatchQ[Flatten@{#},{___String}]&):{},
  query:(_String->_)|{(_String->_)...}:{},
  headers:_Association:<||>
  ]:=
  With[
    {
      u=
        If[MatchQ[OwnValues@$GitHubUsername, {_:>_String, ___}],
          $GitHubUsername,
          None
          ],
      p=
        If[MatchQ[OwnValues@$GitHubPassword, {_:>_String, ___}],
          $GitHubPassword,
          None
          ]
      },
    Block[
      {
        $GitHubUsername:=
          If[StringQ@u, u, GitHubGetDefaultUsername[]],
        $GitHubPassword:=
          If[StringQ@p, p, GitHubPassword[]]
        },
      HTTPRequest[
        URLBuild@
          Join[
            $GitHubQueryBase,
            <|
              "Path"->Flatten@{path},
              "Query"->{query}
              |>
            ],
        Association@Normal@
          GitHubQueryPrepBody@
            GitHubQueryAttachAuth@
              If[TrueQ@$GitHubAuthorizeRequests,
                Merge[
                  {
                    <|"Headers"->{"Authorization"->Automatic}|>,
                    headers
                    },
                  If[OptionQ[Flatten[#]],
                    Normal@Merge[Flatten[#], Last],
                    Last[#]
                    ]&
                  ],
                headers
                ]
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*GitHubQueryParamFilter*)



$GitHubParamMap=<||>;


GitHubQueryParamFilter[s_Symbol, ops_?OptionQ]:=
  With[{kd=Dispatch[$GitHubParamMap[s]]},
    Replace[
      FilterRules[
        Flatten@{
          ops,
          Options[s]
          },
        Keys[$GitHubParamMap[s]]
        ],
      {
        (k_->v:_String|_?NumberQ|True|False):>
          Replace[k, kd]->v,
        _->Nothing
        },
      1
      ]
    ]


(* ::Subsection:: *)
(*Auth*)



(* ::Subsubsection::Closed:: *)
(*GitHubSetUsername*)



$GitHubActions["SetUsername"]:=GitHubSetUsername;


GitHubSetUsername[s_String]:=
  (
    If[$GitHubUseKeychain, 
      $GitHubUsername=s,
      GitHubSetUsername[Automatic]
      ];
    $GitHubConfig["Username"]=s;
    );
GitHubSetUsername[Automatic]:=
  $GitHubUsername:=
    Replace[
      If[$GitHubUseKeychain,  $GitHubKCUsername, None],
      Except[_String]:>
        Replace[$GitHubConfig["Username"],
          Except[_String?StringQ]:>
            GitHubSetUsernameAndPassword[
              "", 
              ""
              ][[1]]
          ]
      ];
GitHubSetUsername[_]:=$Failed;


(* ::Subsubsection::Closed:: *)
(*GitHubSetPassword*)



$GitHubActions["SetPassword"]:=GitHubSetPassword;


GitHubSetPassword[u_String, s_String]:=
  (gitHubPasswordCache[u]=s;);
GitHubSetPassword[s_String]:=
  (gitHubPasswordCache[$GitHubUsername]=s;);
GitHubSetPassword[Automatic]:=Null;
GitHubSetPassword[_]:=$Failed


(* ::Subsubsection::Closed:: *)
(*GitHubGetUsernameAndPassword*)



(*$GitHubActions["GetUsernameAndPassword"]=
	GitHubGetUsernameAndPassword;*)


GitHubGetUsernameAndPassword[u_, p_]:=
  Block[
    {
      username=Replace[u, Automatic:>$GitHubUsername], 
      password=Replace[u, Automatic:>$GitHubPassword]
      },
    If[
      Not[
        StringQ@username&&StringQ@password&&
        StringLength[username]>0&&StringLength[password]>0
        ],
      If[StringQ@username&&$GitHubUseKeychain,
        password=
          KeychainGet[{"github.com", username}]
        ]
      ];
    If[
      Not[
        StringQ@username&&StringQ@password&&
        StringLength[username]>0&&StringLength[password]>0
        ],
        Replace[
          AuthDialog[
            {
              "GitHub", 
              If[StringQ[username], username, ""], 
              If[StringQ[password], password, ""]
              }],
          a_Association?AssociationQ:>
            (
              Set[username, a[["GitHub", 1]]];
              Set[password, a[["GitHub", 2]]];
              )
          ]
        ];
    {username, password}
    ];


(* ::Subsubsection::Closed:: *)
(*GitHubSetUsernameAndPassword*)



(*$GitHubActions["SetUsernameAndPassword"]:=
	GitHubSetUsernameAndPassword;*)


GitHubSetUsernameAndPassword[u_, p_]:=
  With[{up=GitHubGetUsernameAndPassword[u, p]},
    {
      GitHubSetUsername[up[[1]]],
      GitHubSetPassword@@up
      }
    ];


(* ::Subsubsection::Closed:: *)
(*GetPassword*)



$GitHubActions["GetPassword"]=GitHubGetPassword;


GitHubGetPassword//Clear


GitHubGetPassword[Optional[Automatic, Automatic]]:=
  GitHubGetPassword[$GitHubUsername];
GitHubGetPassword[u_String]:=
  GitHubPassword[u];
GitHubGetPassword[e_?Echo]:=$Failed;


(* ::Subsubsection::Closed:: *)
(*GitHubClearPassword*)



$GitHubActions["ClearPassword"]=GitHubClearPassword;


GitHubClearPassword[key_String]:=
  If[$GitHubUseKeychain,
    PackageThrowMessage["Keychain",
      "Password in keychain for must be cleared explicitly via KeychainRemove"
      ],
    Quiet[gitHubPasswordCache[key]=., Unset::norep];
    ];
GitHubClearPassword[Optional[Automatic, Automatic]]:=
  GitHubClearPassword[$GitHubUsername];


(* ::Subsubsection::Closed:: *)
(*AuthHeader*)



$GitHubActions["GetAuthorizationHeader"]=
  GitHubAuthHeader


GitHubAuthHeader[
  user:_String|Automatic:Automatic,
  password:_String|Automatic:Automatic
  ]:=
  With[{up=GitHubGetUsernameAndPassword[user, password]},
    If[Not[AllTrue[up, StringQ[#]&&StringLength[#]>0&]],
      PackageRaiseException[
        "GitHub",
        "GitHub couldn't authenticate user ``",
        Replace[user, Automatic:>$GitHubUsername]
        ],
      StringJoin@{
        "Basic ",
        Developer`EncodeBase64@
          StringJoin@{up[[1]],":",up[[2]]}
        }
      ]
    ];


(* ::Subsection:: *)
(*OAuth*)



(* ::Subsubsection::Closed:: *)
(*Clear*)



GitHubClearAuth[
  user:(_String|Automatic):Automatic,
  clientID:_String|Automatic:Automatic,
  scope:_String?GHOAuthScopeQ:"drive"
  ]:=
  With[
    {
      u=
        StringTrim[
          Replace[user, Automatic:>$GitHubUsername],
          "@gmail.com"
          ],
      cid=
        Replace[clientID, Automatic:>$GitHubClientID],
      kc=$GHCacheSym
      },
    kc[{u,cid,scope,"token"}]=.;
    kc[{u,cid,scope,"code"}]=.;
    ];


(* ::Subsubsection::Closed:: *)
(*Scopes*)



(*$GAOAuthScopes=
	<|
		"drive"->
			{
				"file",
				"appdata",
				"metadata",
				"metadata.readonly",
				"photos.readonly",
				"readonly",
				"scripts"
				}
		|>;*)


(*GAOAuthScopeQ[s_]:=
	(KeyMemberQ[$GAOAuthScopes,ToLowerCase@s]||
		With[{sp=StringSplit[ToLowerCase@s,".",2]},
			MemberQ[
				$GAOAuthScopes[First@sp],
				Last@sp
				]
			]
		);*)


(* ::Subsubsection::Closed:: *)
(*Requests*)



(*GAOAuthCodeURL[
	clientID_,
	scope_
	]:=
	With[{
		cid=
			Replace[clientID,
				Automatic\[RuleDelayed]
					$GAClientID
				],
		s=URLBuild@{"https://www.googleapis.com/auth",scope}
		},
		URLBuild@
			GAURLAssoc["OAuthCode",
				"client_id"\[Rule]cid,
				"scope"\[Rule]s
				]
		];*)


(*GAOAuthTokenRequest[code_]:=
	HTTPRequest[
		URLBuild@GAURLAssoc["OAuthToken"],
		<|
			"Method"\[Rule]"Post",
			"Body"\[Rule]{
				"code"\[Rule]code,
				"client_id"\[Rule]$GAClientID,
				"client_secret"\[Rule]$GAClientSecret,
				"grant_type"\[Rule]"authorization_code",
				"redirect_uri"->"http://localhost/oauth2callback"
				}
			|>
		];
GAOAuthRefreshRequest[token_]:=
	HTTPRequest[
		URLBuild@GAURLAssoc["OAuthToken"],
		<|
			"Method"\[Rule]"Post",
			"Body"\[Rule]{
				"refresh_token"\[Rule]token,
				"client_id"\[Rule]$GAClientID,
				"client_secret"\[Rule]$GAClientSecret,
				"grant_type"\[Rule]"refresh_token"
				}
			|>
		];*)


(* ::Subsubsection::Closed:: *)
(*Auth*)



(*GAOAuthenticate[
	user:(_String|Automatic):Automatic,
	clientID:_String|Automatic:Automatic,
	scope:_String?GAOAuthScopeQ:"drive"
	]:=
	With[{
		u=
			StringTrim[
				Replace[user, Automatic\[RuleDelayed]$GoogleAPIUsername],
				"@gmail.com"
				],
		cid=
			Replace[clientID, Automatic\[RuleDelayed]$GAClientID]
			},
		With[{a=GAOAuthTokenData[u, cid, scope]},
			Block[{
				$GAOAuthTokenDataTmp=a,
				$GAOAuthTokenCalls=
					If[!IntegerQ@$GAOAuthTokenCalls, 0, $GAOAuthTokenCalls]
				},
				If[$GAOAuthTokenCalls<4&&AssociationQ@a,
					$GAOAuthTokenCalls++;
					If[
						Quantity[ToExpression@#,"Seconds"]>(Now-#2)&@@
							Lookup[a,{"expires_in","LastUpdated"}, 3600],
						Lookup[a,"access_token"],
						If[KeyMemberQ[a,"refresh_token"],
							Replace[Import[GAOAuthRefreshRequest@a["refresh_token"],"RawJSON"],{
								r_Association:>
									With[{kc=$GACacheSym},
										kc[{u,cid,scope,"token"}]=
											Append[r,"LastUpdated"\[Rule]Now];
										GAOAuthenticate[u,cid,scope]
										],
								_->$Failed
								}],
							If[$GAOAuthTokenCalls>1&&KeyMemberQ[a,"access_token"],
								a["access_token"],
								GoogleAPIClearAuth[u,cid,scope];
								GAOAuthenticate[u,cid,scope]
								]
							],
						$Failed
						],
					$Failed
					]
				]
			]
		];*)


(* ::Subsubsection::Closed:: *)
(*OAuthTokenData*)



(*GAOAuthTokenData[
	user:_String|Automatic:Automatic,
	clientID:_String|Automatic:Automatic,
	scope:_String?GAOAuthScopeQ:"drive"
	]:=
	Replace[$GAOAuthTokenDataTmp,
		Except[_String]:>
			With[
				{
					u=
						StringTrim[
							Replace[user,Automatic\[RuleDelayed]$GoogleAPIUsername],
							"@gmail.com"
							],
					cid=
						Replace[clientID,Automatic\[RuleDelayed]$GAClientID],
					kc=$GACacheSym
					},
				Replace[kc[{u,cid,scope,"token"}],
					Except[_Association?(KeyMemberQ["access_token"])]:>
						Replace[
							Replace[kc[{u,clientID,scope,"code"}],
								Except[_String?(StringLength@#>0&)]:>
									Replace[
										OAuthDialog[
											"Google OAuth Authorization",
											{
												{"Google OAuth",GAOAuthCodeURL[cid,scope]},
												$GAKeyExample
												},
											$GAParameters["Root","Domain"]
											],
										s_String?(StringLength@#>0&):>
											(kc[{u,cid,scope,"code"}]=s)
										]
								],{
							code_String?(StringLength@#>0&):>
								Replace[Import[GAOAuthTokenRequest[code],"RawJSON"],
									r_Association?(KeyMemberQ["access_token"]):>
										(
											kc[{u,cid,scope,"token"}]=
												Append[r,"LastUpdated"\[Rule]Now]
											)
									]
							}]
					]
				]
		];*)


(* ::Subsection:: *)
(*UserAPI*)



(* ::Subsubsection::Closed:: *)
(*UserAPI*)



GitHubUserAPI[
  type:"users"|"org"|"user"|None:"users",
  user:_String|Automatic:Automatic,
  path:{___String}|_String:{},
  query:(_String->_)|{(_String->_)...}:{},
  headers:_Association:<||>
  ]:=
  GitHubQuery[
    {
      If[type===None, Nothing, type],
      Replace[user, 
        Automatic:>
          If[type==="user"||type===None, Nothing, $GitHubUsername]
        ],
      Flatten@path
      },
    query,
    headers
    ];


(* ::Subsection:: *)
(*Repos API*)



(* ::Subsubsection::Closed:: *)
(*ReposAPI*)



GitHubReposAPI[
  repo_GitHubPath?GitHubRepoQ,
  path:{___String}|_String:{},
  query:(_String->_)|{(_String->_)...}:{},
  headers:_Association:<||>
  ]:=
  GitHubQuery[
    Flatten@{
      "repos",
      Sequence@@Normal@repo,
      path
      },
    query,
    headers
    ];
GitHubReposAPI[
  s_String?GitHubRepoQ,
  path:{___String}|_String:{},
  query:(_String->_)|{(_String->_)...}:{},
  headers:_Association:<||>
  ]:=
  GitHubReposAPI[
    GitHubPathParse[If[URLParse[s, "Scheme"]===None, "github:"<>s, s]],
    path,
    query,
    headers
    ];


(* ::Subsubsection::Closed:: *)
(*UserReposAPI*)



GitHubUserReposAPI[
  path:{___String}|_String:{},
  query:(_String->_)|{(_String->_)...}:{},
  headers:_Association:<||>
  ]:=
  GitHubQuery[
    Flatten@{
      "user",
      "repos",
      path
      },
    query,
    headers
    ];


(* ::Subsection:: *)
(*Repositories*)



(* ::Subsubsection::Closed:: *)
(*Repositories*)



$GitHubActions["ListRepositories"]=
  GitHubRepositories;


GitHubRepositories//Clear


GitHubRepositories[
  type:"users"|"org":"users",
  user:_String|Automatic:Automatic,
  query:(_String->_)|{(_String->_)...}:{},
  headers:_Association:<||>
  ]:=
  GitHubUserAPI[type, user, {"repos"}, query, headers];


(* ::Subsubsection::Closed:: *)
(*ListMyRepositories*)



$GitHubActions["ListMyRepositories"]=GitHubListMyRepositories;


$GitHubParamMap[GitHubListMyRepositories]=
  {
    "Visibility"->"visibility",
    "Affiliation"->"affiliation",
    "Type"->"type",
    "Sort"->"sort",
    "SortDirection"->"direction"
    };


Options[GitHubListMyRepositories]=
  Join[
    Thread[Keys[$GitHubParamMap[GitHubListMyRepositories]]->Automatic],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubListMyRepositories[
  ops:OptionsPattern[]
  ]:=
  GitHubUserReposAPI[
    {}, 
    GitHubQueryParamFilter[
      GitHubListMyRepositories,
      {
        ops
        }
      ],
    <|
      "Headers"->
        {  
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ];


(* ::Subsubsection::Closed:: *)
(*RepositoryInfo*)



$GitHubActions["GetRepository"]=
  GitHubRepositoryInfo;


GitHubRepositoryInfo[
  repo:(_String|_GitHubPath)?GitHubRepoQ
  ]:=
  GitHubReposAPI[
    repo
    ]


(* ::Subsubsection::Closed:: *)
(*Create*)



$GitHubActions["Create"]=GitHubCreate;
$GitHubActions["CreateRepository"]=GitHubCreate;


$GitHubParamMap[GitHubCreate]=
  {
    "Name"->"name",
    "Description"->"description",
    "Private"->"private",
    "HomePage"->"homepage",
    "AutoInit"->"auto_init",
    "HasWiki"->"has_issues",
    "HasProjects"->"has_projects",
    "HasIssues"->"has_wiki",
    "Private"->"team_id",
    "GitIgnore"->"gitignore_template",
    "LicenseTemplate"->"license_template",
    "AllowSquashMerge"->"allow_squash_merge",
    "AllowMergeCommit"->"allow_merge_commit",
    "AllowRebaseMerge"->"allow_rebase_merge"
    };


Options[GitHubCreate]=
  Join[
    Thread[Keys[$GitHubParamMap[GitHubCreate]]->Automatic],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubCreate[
  repo:_String,
  ops:OptionsPattern[]
  ]:=
  GitHubUserReposAPI[
    <|
      "Method"->"POST",
      "Body"->
        ExportString[
          GitHubQueryParamFilter[
            GitHubCreate,
            {
              "Name"->repo,
              ops
              }
            ],
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
            }
      |>
    ];


(* ::Subsubsection::Closed:: *)
(*EditRepository*)



$GitHubActions["EditRepository"]=GitHubEdit;
$GitHubActions["Edit"]=GitHubEdit;


$GitHubParamMap[GitHubEdit]=
  $GitHubParamMap[GitHubCreate];
Options[GitHubEdit]=
  Join[
    Thread[Keys[$GitHubParamMap[GitHubEdit]]->Automatic],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubEdit[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    <|
      "Method"->"PATCH",
      "Body"->
        ExportString[
          GitHubQueryParamFilter[
            GitHubEdit,
            {
              ops
              }
            ],
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
            }
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*Delete*)



$GitHubActions["Delete"]=GitHubDelete;
$GitHubActions["DeleteRepository"]=GitHubDelete;


GitHubDelete//ClearAll


Options[GitHubDelete]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubDelete[
  repo_GitHubPath?GitHubRepoQ,
  ops:OptionsPattern[]
  ]:=
  With[{uu=URLParse[URL@repo]},
    GitHubReposAPI[
      repo,
      <|
        "Method"->"DELETE",
        "Headers"->
          {
            "Authorization"->
              OptionValue[{"Username", "Password"}]
              }
        |>
      ]
    ];
GitHubDelete[
  s_String?GitHubRepoQ,
  ops:OptionsPattern[]
  ]:=
  Block[{$GitHubPathFormat=False},
    GitHubDelete[
      GitHubPath[s, FilterRules[{ops}, Options@GitHubPath]],
      ops
      ]
    ];
(*GitHubDelete[
	s_String?(
		URLParse[#,"Scheme"]===None&&
		Length@URLParse[#,"Path"]===1&
		),
	ops:OptionsPattern[]
	]:=
	GitHubDelete[
		GitHubPath[s,
			FilterRules[{ops},Options@GitHubPath]
			],
		ops]*)


(* ::Subsubsection::Closed:: *)
(*Contributors*)



$GitHubParamMap[GitHubRepositoryContributors]=
  {
    "AnonymousContributors"->"anon"
    };


Options[GitHubRepositoryContributors]=
  $GitHubParamMap[GitHubRepositoryContributors];
GitHubRepositoryContributors[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"contributors"}
    ];


(* ::Subsection:: *)
(*Webhooks*)



(* ::Subsubsection::Closed:: *)
(*ListForks *)



$GitHubActions["ListHooks"]=
  GitHubListHooks;


Options[GitHubListHooks]=
  {
    };
GitHubListHooks[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"hooks"}
    ]


(* ::Subsubsection::Closed:: *)
(*HookInfo*)



$GitHubActions["HookInfo"]=
  GitHubHookInfo;


Options[GitHubHookInfo]=
  {
    };
GitHubHookInfo[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  hook_Integer,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"hooks", ToString@hook}
    ];


(* ::Subsubsection::Closed:: *)
(*CreateHook*)



$GitHubActions["CreateHook"]=GitHubCreateHook;
$GitHubParamMap[GitHubCreateHookConfig]=
  {
    "URL"->"url",
    "ContentType"->"content_type",
    "SecretKey"->"secret",
    "AllowInsecureSSL"->"insecure_ssl"
    }
$GitHubParamMap[GitHubCreateHook]=
  {
    "Name"->"name",
    "Events"->"events",
    "Active"->"active",
    "Configuration"->"config"
    };
Options[GitHubCreateHook]=
  Join[
    FilterRules[
      Thread[Keys[$GitHubParamMap[GitHubCreateHook]]->Automatic],
      Except["Events"|"Configuration"]
      ],
    FilterRules[
      Thread[Keys[$GitHubParamMap[GitHubCreateHookConfig]]->Automatic],
      Except["URL"]
      ],
    {
      "Events"->{"*"}
      },
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];


GitHubCreateHook[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  hook_String,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"hooks"},
    <|
      Method->"POST",
      "Body"->
        ExportString[
          GitHubQueryParamFilter[
            GitHubCreateHook,
            {
              ops,
              "Configuration"->
                GitHubQueryParamFilter[
                  GitHubCreateHookConfig,
                  {
                    ops,
                    "URL"->hook
                    }
                  ]
              }
            ],
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*EditHook*)



$GitHubActions["EditHook"]=GitHubEditHook;
$GitHubParamMap[GitHubEditHook]=
  {
    "Events"->"events",
    "AddEvents"->"add_events",
    "RemoveEvents"->"remove_events",
    "Active"->"active",
    "Configuration"->"config"
    };
Options[GitHubEditHook]=
  Join[
    FilterRules[
      Thread[Keys[$GitHubParamMap[GitHubEditHook]]->Automatic],
      Except["Configuration"]
      ],
    Thread[Keys[$GitHubParamMap[GitHubCreateHookConfig]]->Automatic],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubEditHook[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  which:_?IntegerQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"hooks", ToString@which},
    <|
      Method->"PATCH",
      "Body"->
        ExportString[
          GitHubQueryParamFilter[
            GitHubEditHook,
            {
              ops,
              "Configuration"->
                GitHubQueryParamFilter[
                  GitHubCreateHookConfig,
                  {
                    ops
                    }
                  ]
              }
            ],
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*DeleteHook*)



$GitHubActions["DeleteHook"]=GitHubDeleteHook;


GitHubDeleteHook//ClearAll


Options[GitHubDeleteHook]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubDeleteHook[
  repo_GitHubPath?GitHubRepoQ,
  hook_Integer,
  ops:OptionsPattern[]
  ]:=
  With[{uu=URLParse[URL@repo]},
    GitHubReposAPI[
      repo,
      {"hooks", ToString@hook},
      <|
        "Method"->"DELETE",
        "Headers"->
          {
            "Authorization"->
              OptionValue[{"Username", "Password"}]
              }
        |>
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*PingHook*)



$GitHubActions["PingHook"]=
  GitHubPingHook;


Options[GitHubHookInfo]=
  {
    };
GitHubHookInfo[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  hook_Integer,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"hooks", ToString@hook, "pings"}
    ];


(* ::Subsection:: *)
(*GitDataAPI*)



(* ::Subsubsection::Closed:: *)
(*GitDataAPI*)



GitHubGitDataAPI[
  repo_GitHubPath?GitHubRepoQ,
  part:"blobs"|"commits"|"refs"|"tags"|"trees",
  path:{___String}|_String:{},
  query:(_String->_)|{(_String->_)...}:{},
  headers:_Association:<||>
  ]:=
  GitHubReposAPI[
    repo,
    Flatten[{"git", part, path}],
    query,
    headers
    ];
GitHubGitDataAPI[
  s_String?GitHubRepoQ,
  part:"blobs"|"commits"|"refs"|"tags"|"trees",
  path:{___String}|_String:{},
  query:(_String->_)|{(_String->_)...}:{},
  headers:_Association:<||>
  ]:=
  GitHubGitDataAPI[
    GitHubPathParse[If[URLParse[s, "Scheme"]===None, "github:"<>s, s]],
    part,
    path,
    query,
    headers
    ];


(* ::Subsection:: *)
(*Branches*)



(* ::Subsubsection::Closed:: *)
(*Branches*)



GitHubRepositoryBranches[
  repo:(_String|_GitHubPath)?GitHubRepoQ
  ]:=
  GitHubReposAPI[
    repo,
    {"branches"}
    ];


(* ::Subsubsection::Closed:: *)
(*BranchInfo*)



GitHubRepositoryBranchInfo[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  branch_String
  ]:=
  GitHubReposAPI[
    repo,
    {"branches", branch}
    ];


(* ::Subsection:: *)
(*Forks*)



(* ::Subsubsection::Closed:: *)
(*ListForks *)



Options[GitHubListForks]=
  {
    "Sort"->None
    };
GitHubListForks[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"forks"},
    Replace[OptionValue["Sort"],
      {
        Except[_String]:>Sequence@@{},
        s_String:>("sort"->s)
        }
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*Fork *)



GitHubFork//Clear


Options[GitHubFork]=
  {
    "Organization"->None,
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubFork[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"forks"},
    Replace[OptionValue["Organization"],
      {
        Except[_String]:>Sequence@@{},
        s_String:>("organization"->s)
        }
      ],
    <|
      "Method"->"POST",
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]
      


(* ::Subsection:: *)
(*Issues*)



(* ::Subsubsection::Closed:: *)
(*UserIssues*)



$GitHubActions["ListUserIssues"]=
  GitHubIssues;


GitHubIssues//Clear


$GitHubParamMap[GitHubIssues]=
  {
    "Filter"->"filter",
    "State"->"state",
    "Labels"->"labels",
    "Sort"->"sort",
    "SortDirection"->"direction",
    "Since"->"since"
    };
Options[GitHubIssues]=
  Thread[Keys[$GitHubParamMap[GitHubIssues]]->Automatic];
GitHubIssues[
  type:"org"|"user":"user",
  user:_String|Automatic:Automatic,
  ops:OptionsPattern[]
  ]:=
  GitHubUserAPI[
    If[user==="Assigned", None, type],
    Which[
      user==="Assigned",
        Automatic,
     type==="org", 
       user, 
     True,
       Automatic
     ],
    {"issues"}, 
    GitHubQueryParamFilter[
      GitHubIssues,
      {
        ops
        }
      ],
    <|
      |>
    ];


(* ::Subsubsection::Closed:: *)
(*RepositoryIssues*)



$GitHubActions["ListIssues"]=GitHubRepositoryIssues;
$GitHubParamMap[GitHubRepositoryIssues]=
  {
    "Milestone"->"milestone",
    "State"->"state",
    "Assignee"->"assignee",
    "Creator"->"creator",
    "Mentioned"->"mentioned",
    "Labels"->"labels",
    "Sort"->"sort",
    "SortDirection"->"direction",
    "Since"->"since"
    };
Options[GitHubRepositoryIssues]=
  Thread[Keys[$GitHubParamMap[GitHubRepositoryIssues]]->Automatic];
GitHubRepositoryIssues[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"issues"},
    GitHubQueryParamFilter[
      GitHubRepositoryIssues,
      {
        ops
        }
      ],
    <|
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*GetIssue*)



$GitHubActions["GetIssue"]=GitHubGetIssue;
GitHubGetIssue[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  id:_Integer?IntegerQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"issues", ToString@id}
    ]


(* ::Subsubsection::Closed:: *)
(*CreateIssue*)



$GitHubActions["CreateIssue"]=GitHubCreateIssue;
$GitHubParamMap[GitHubCreateIssue]=
  {
    "Title"->"title",
    "Body"->"body",
    "Milestone"->"milestone",
    "Labels"->"labels",
    "Assignees"->"assignees"
    };
Options[GitHubCreateIssue]=
  Join[
    FilterRules[
      Thread[Keys[$GitHubParamMap[GitHubCreateIssue]]->Automatic],
      Except["Title"|"Body"]
      ],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubCreateIssue[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  title_String,
  body_String,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"issues"},
    <|
      Method->"POST",
      "Body"->
        ExportString[
          GitHubQueryParamFilter[
            GitHubCreateIssue,
            {
              ops,
              "Title"->title,
              "Body"->body
              }
            ],
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*EditIssue*)



$GitHubActions["EditIssue"]=GitHubEditIssue;
$GitHubParamMap[GitHubEditIssue]=
  {
    "Title"->"title",
    "Body"->"body",
    "State"->"state",
    "Milestone"->"milestone",
    "Labels"->"labels",
    "Assignees"->"assignees"
    };
Options[GitHubEditIssue]=
  Join[
    Thread[Keys[$GitHubParamMap[GitHubEditIssue]]->Automatic],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubEditIssue[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  which:_?IntegerQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"issues", ToString@which},
    <|
      Method->"PATCH",
      "Body"->
        ExportString[
          GitHubQueryParamFilter[
            GitHubEditIssue,
            {ops}
            ],
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*ListIssueComments*)



$GitHubActions["ListIssueComments"]=GitHubListIssueComments;
$GitHubParamMap[GitHubListIssueComments]=
  {
    "Since"->"since"
    };
Options[GitHubListIssueComments]=
  Thread[Keys[$GitHubParamMap[GitHubListIssueComments]]->Automatic];
GitHubListIssueComments[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  which:_Integer?IntegerQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"issues", ToString@which, "comments"},
    GitHubQueryParamFilter[
      GitHubListIssueComments,
      {
        ops
        }
      ],
    <|
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*CreateIssueComment*)



$GitHubActions["CreateIssueComment"]=GitHubCreateIssueComment;
Options[GitHubCreateIssueComment]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubCreateIssueComment[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  which_?IntegerQ,
  body_String,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"issues", ToString@which, "comments"},
    <|
      Method->"POST",
      "Body"->
        ExportString[
          {
            "body"->body
            },
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*EditIssueComment*)



$GitHubActions["EditIssueComment"]=GitHubEditIssueComment;
Options[GitHubEditIssueComment]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubEditIssueComment[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  which_?IntegerQ,
  subwhich_?IntegerQ,
  body_String,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"issues", ToString@which, "comments", ToString@subwhich},
    <|
      Method->"PATCH",
      "Body"->
        ExportString[
          {
            "body"->body
            },
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*DeleteIssueComment*)



$GitHubActions["DeleteIssueComment"]=GitHubDeleteIssueComment;
Options[GitHubDeleteIssueComment]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubDeleteIssueComment[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  subwhich_?IntegerQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    ToString/@{"issues", "comments", subwhich},
    <|
      Method->"DELETE",
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsection:: *)
(*Blobs*)



(* ::Subsubsection::Closed:: *)
(*GetBlob*)



$GitHubActions["GetBlob"]=GitHubGetBlob;


GitHubGetBlob[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]])
  ]:=
  GitHubGitDataAPI[
    repo,
    "blobs",
    {sha},
    <|
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*CreateBlob*)



$GitHubActions["CreateBlob"]=GitHubCreateBlob;


Options[GitHubCreateBlob]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubCreateBlob[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  blob:_String|_File,
  ops:OptionsPattern[]
  ]:=
  GitHubGitDataAPI[
    repo,
    "blobs",
    {},
    <|
      "Method"->"POST",
      "Body"->
        ExportString[
          {
            "content"->
              If[StringQ@blob,
                If[StringLength[blob]>10^6,
                  With[{f=CreateFile[]}, 
                    WriteString[f, blob];
                    Close@f;
                    File[f]
                    ],
                  Developer`EncodeBase64[blob]
                  ],
                blob
                ],
            "encoding"->"base64"
            },
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]
      


(* ::Subsection:: *)
(*Commits*)



(* ::Subsubsection::Closed:: *)
(*GetCommit*)



$GitHubActions["GetCommit"]=GitHubGetCommit;


GitHubGetCommit[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]])
  ]:=
  GitHubGitDataAPI[
    repo,
    "commits",
    {sha},
    <|
      |>
    ]


(* ::Subsection:: *)
(*References*)



(* ::Subsubsection::Closed:: *)
(*GetReference*)



$GitHubActions["GetReference"]=GitHubGetReference;


GitHubGetReference[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  which:_String:"master"
  ]:=
  GitHubGitDataAPI[
    repo,
    "refs",
    {"heads/"<>StringTrim[which, "heads/"]},
    <|
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*GetAllReferences*)



$GitHubActions["GetAllReferences"]=GitHubGetAllReferences;


GitHubGetAllReferences[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  which:_String|None:None
  ]:=
  GitHubGitDataAPI[
    repo,
    "refs",
    {If[which===None, Nothing, which]},
    <|
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*CreateReference*)



$GitHubActions["CreateReference"]=GitHubCreateReference;


Options[GitHubCreateReference]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubCreateReference[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  ref:_String,
  sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]]),
  ops:OptionsPattern[]
  ]:=
  GitHubGitDataAPI[
    repo,
    "refs",
    {},
    <|
      "Method"->"POST",
      "Body"->
        ExportString[
          {
            "ref"->
              With[{s1=StringTrim[ref, "refs/"]},
                If[StringContainsQ[s1, "/"],
                  "refs/"<>s1,
                  "refs/heads/"<>s1
                  ]
                ],
            "sha"->sha
            },
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]
      


(* ::Subsubsection::Closed:: *)
(*UpdateReference*)



$GitHubActions["UpdateReference"]=GitHubUpdateReference;


$GitHubParamMap[GitHubUpdateReference]=
  {
    "ForceUpdate"->"force"
    };
Options[GitHubUpdateReference]=
  Join[
    $GitHubParamMap[GitHubUpdateReference],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubUpdateReference[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  ref:_String,
  sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]]),
  ops:OptionsPattern[]
  ]:=
  GitHubGitDataAPI[
    repo,
    "refs",
    {
      With[{s1=StringTrim[ref, "refs/"]},
        If[StringContainsQ[s1, "/"],
          s1,
          "heads/"<>s1
          ]
        ]
      },
    <|
      "Method"->"PATCH",
      "Body"->
        ExportString[
          {
            "sha"->sha,
            "force"->If[TrueQ@OptionValue["ForceUpdate"], "true", "false"]
            },
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]
      


(* ::Subsubsection::Closed:: *)
(*DeleteReference*)



$GitHubActions["DeleteReference"]=GitHubDeleteReference;


Options[GitHubDeleteReference]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubDeleteReference[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  ref:_String,
  ops:OptionsPattern[]
  ]:=
  GitHubGitDataAPI[
    repo,
    "refs",
    {
      With[{s1=StringTrim[ref, "refs/"]},
        If[StringContainsQ[s1, "/"],
          s1,
          "heads/"<>s1
          ]
        ]
      },
    <|
      "Method"->"DELTE",
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsection:: *)
(*Tags*)



(* ::Subsubsection::Closed:: *)
(*GetTag*)



$GitHubActions["GetTag"]=GitHubGetTag;


GitHubGetTag[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]])
  ]:=
  GitHubGitDataAPI[
    repo,
    "tags",
    {sha},
    <|
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*CreateTag*)



$GitHubActions["CreateTag"]=GitHubCreateTag;


$GitHubParamMap[GitHubCreateTag]=
  {
    "Name"->"name",
    "Email"->"email",
    "Date"->"date"
    };


Options[GitHubCreateTag]=
  Thread[Keys[$GitHubParamMap[GitHubCreateTag]]->Automatic];
GitHubCreateTag[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  tag:_String?(StringFreeQ[WhitespaceCharacter]),
  message:_String,
  sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]]),
  type:"commit"|"tree"|"blob":"commit",
  ops:OptionsPattern[]
  ]:=
  GitHubGitDataAPI[
    repo,
    "tags",
    <|
      "Method"->"POST",
      "Body"->
        ExportString[
          With[
            {
              pars=
                GitHubQueryParamFilter[
                  GitHubCreateTag,
                  {ops}
                  ]
              },
            {
              "tag"->tag,
              "message"->message,
              "object"->sha,
              "type"->type,
              Replace[
                Lookup[pars, {"name", "email", "date"}],
                {
                  l:{__String}:>
                    ("tagger"->
                      Thread[
                        {"name", "email", "date"}->
                        l
                        ]),
                    _->Nothing
                    }
                ]
              }
            ],
          "JSON"
          ]
      |>
    ]


(* ::Subsection:: *)
(*Trees*)



(* ::Subsubsection::Closed:: *)
(*GetTree*)



$GitHubActions["GetTree"]=GitHubGetTree;


Options[GitHubGetTree]=
  {
    "Recursive"->False
    };
GitHubGetTree[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  sha:_String?(StringMatchQ[Repeated[WordCharacter, {30, Infinity}]])
  ]:=
  GitHubGitDataAPI[
    repo,
    "trees",
    {sha},
    {
      Replace[OptionValue["Recursive"], 
        {
          s:_String|_Integer:>("recursive"->ToString[s]),
          True->("recursive"->"1"),
          _->Nothing
          }
        ]
      },
    <|
      |>
    ]


(* ::Subsection:: *)
(*Merges*)



(* ::Subsubsection::Closed:: *)
(*Merge*)



(* ::Text:: *)
(*
	Need to fix this up so it can appropriately handle upstream merges
*)



$GitHubActions["Merge"]=GitHubMerge;


$GitHubParamMap[GitHubMerge]=
  {
    "TargetBranch"->"base",
    "Message"->"commit_message"
    };


Options[GitHubMerge]=
  Join[
    Thread[
      DeleteCases[
        Keys[$GitHubParamMap[GitHubMerge]], 
        "SourceBranch"
        ]->Automatic
      ],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubMerge[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  source:(_GitHubPath?GitHubRepoQ|_String),
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"merges"},
    {},
    <|
      "Method"->"POST",
      "Body"->
        ExportString[
          Prepend[
            GitHubQueryParamFilter[
              GitHubMerge,
              DeleteDuplicatesBy[First]@{
                ops,
                "TargetBranch"->
                  "master",
                "Message"->
                  TemplateApply[
                    "Merge `` into ``",
                    {
                      Replace[source,
                        _GitHubPath:>StringRiffle[Normal[source], "/"]
                        ],
                      URLBuild@
                        URLParse[
                          If[StringQ@repo, repo, URL@repo], 
                          "Path"
                          ]
                      }
                    ]
                }
                ],
              "head"->
                If[GitHubRepoQ@source,
                  Replace[
                    GitHub["GetReference", source, "master",
                      "ImportedResult"
                      ]["Content"],
                    {
                      a_Association:>a["Object", "SHA"],
                      e_:>Throw[$Failed]
                      }
                    ],
                  source
                  ]
              ],
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]
      


(* ::Subsection:: *)
(*Pulls*)



(* ::Subsubsection::Closed:: *)
(*ListPullRequests*)



$GitHubActions["ListPullRequests"]=GitHubListPullRequests;
$GitHubParamMap[GitHubListPullRequests]=
  {
    "State"->"state",
    "UserBranch"->"head",
    "BranchName"->"base",
    "Sort"->"sort",
    "SortDirection"->"direction"
    };
Options[GitHubListPullRequests]=
  Thread[Keys[$GitHubParamMap[GitHubListPullRequests]]->Automatic];
GitHubListPullRequests[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"pulls"},
    GitHubQueryParamFilter[
      GitHubListPullRequests,
      {
        ops
        }
      ],
    <|
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*PullRequestInfo*)



$GitHubActions["PullRequestInfo"]=GitHubPullRequestInfo;


GitHubPullRequestInfo[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  pull:_Integer?Positive
  ]:=
  GitHubReposAPI[
    repo,
    {"pulls", ToString[pull]}
    ]


(* ::Subsubsection::Closed:: *)
(*CreatePullRequest*)



$GitHubActions["CreatePullRequest"]=GitHubCreatePullRequest;
$GitHubParamMap[GitHubCreatePullRequest]=
  {
    "Title"->"title",
    "SourceBranch"->"head",
    "TargetBranch"->"base",
    "Description"->"body",
    "Modifiable"->"maintainer_can_modify"
    };
Options[GitHubCreatePullRequest]=
  Join[
    Thread[Keys[$GitHubParamMap[GitHubCreatePullRequest]]->Automatic],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubCreatePullRequest[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"pulls"},
    <|
      Method->"POST",
      "Body"->
        ExportString[
          GitHubQueryParamFilter[
            GitHubCreatePullRequest,
            DeleteDuplicatesBy[First]@{
              ops,
              "Modifiable"->True,
              "SourceBranch"->
                Replace[
                  OptionValue["Username"],
                  Automatic:>$GitHubUsername
                  ]<>":master",
              "TargetBranch"->"master",
              "Title"->
                TemplateApply[
                  "Pull request from ``",
                  URLBuild@
                    Append[
                      URLParse[
                        If[StringQ@repo, repo, URL@repo], 
                        "Path"
                        ],
                      Replace[OptionValue["SourceBranch"],
                        Except[_String]:>"master"
                        ]
                      ]
                  ]
              }
            ],
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsection:: *)
(*READMEs*)



(* ::Subsubsection::Closed:: *)
(*CreateReadme*)



GitHubCreateReadme[repo_?GitRepoQ,readmeText:_String:""]:=
  With[{o=
    OpenWrite@
      FileNameJoin@{
        repo,
        "README.md"
        }
    },
    WriteString[o,readmeText];
    Close@o
    ];


(* ::Subsubsection::Closed:: *)
(*GetReadme*)



GitHubGetReadme[
  repo:(_String|_GitHubPath)?GitHubRepoQ
  ]:=
  GitHubReposAPI[
    repo,
    {"readme"}
    ];


(* ::Subsection:: *)
(*Files*)



(* ::Subsubsection::Closed:: *)
(*GetFile*)



$GitHubActions["GetFile"]=
  GitHubGetFile;
$GitHubActions["GetDirectory"]=
  GitHubGetFile;


GitHubGetFile[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  path_String
  ]:=
  GitHubReposAPI[
    repo,
    {"contents", path}
    ];


(* ::Subsubsection::Closed:: *)
(*GetFileSHA*)



$GitHubActions["GetFileSHA"]=GitHubGetFileSHA;


GitHubGetFileSHA[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  path:_String
  ]:=
  SelectFirst[
    GitHub["GetDirectory", repo, 
      StringRiffle[Most@StringSplit[path, "/"], "/"]
      ]["Content"],
    #Path==path&,
    <|"SHA"->None|>
    ]["SHA"]


(* ::Subsubsection::Closed:: *)
(*AddFile*)



$GitHubParamMap[GitHubAddFile]=
  {
    "Message"->"message",
    "Branch"->"branch",
    "Committer"->"committer",
    "Author"->"author"
    };


Options[GitHubAddFile]=
  Join[
    Thread[Keys[$GitHubParamMap[GitHubAddFile]]->Automatic],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubAddFile[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  file_String?FileExistsQ,
  pathy:_String|Automatic:Automatic,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      path=
        Replace[pathy,
          {
            Except[_String]:>FileNameTake[file]
            }
          ]
      },
    GitHubReposAPI[
      repo,
      {
        "contents", 
        Replace[path,
          {
            Except[_String]:>FileNameTake[file]
            }
          ]
        },
      <|
        Method->"PUT",
        "Body"->
          Prepend[
            GitHubQueryParamFilter[
              GitHubAddFile,
              DeleteDuplicatesBy[First]@
                {
                  "Message"->
                      Replace[OptionValue["Message"], 
                        Automatic:>TemplateApply["Added ``", path]
                        ],
                  ops
                  }
              ],
            "content"->
              File[file]
            ],
        "Headers"->
          {
            "Authorization"->
              OptionValue[{"Username", "Password"}]
              }
        |>
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*EditFile*)



$GitHubActions["EditFile"]=GitHubEditFile;


$GitHubParamMap[GitHubEditFile]=
  {
    "Message"->"message",
    "Branch"->"branch",
    "Committer"->"committer",
    "Author"->"author",
    "CommitSHA"->"sha"
    };


Options[GitHubEditFile]=
  Join[
    Thread[Keys[$GitHubParamMap[GitHubEditFile]]->Automatic],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubEditFile[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  file:_String?FileExistsQ,
  pathy:_String|Automatic:Automatic,
  ops:OptionsPattern[]
  ]:=
  With[{path=
    Replace[pathy,
        {
          Except[_String]:>FileNameTake[file]
          }
        ]
    },
    GitHubReposAPI[
      repo,
      {"contents", path},
      <|
        Method->"PUT",
        "Body"->
          Prepend[
            GitHubQueryParamFilter[
              GitHubEditFile,
              DeleteDuplicatesBy[First]@{
                "CommitSHA"->
                  Replace[OptionValue["CommitSHA"],
                    Except[_String]:>
                      GitHubGetFileSHA[repo, path]
                    ],
                "Message"->
                  Replace[OptionValue["Message"], 
                    Automatic:>TemplateApply["Updated ``", path]
                    ],
                ops
                
                }
              ],
            "content"->
              File[file]
            ],
        "Headers"->
          {
            "Authorization"->
              OptionValue[{"Username", "Password"}]
              }
        |>
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*DeleteFile*)



$GitHubParamMap[GitHubDeleteFile]=
  {
    "Message"->"message",
    "Branch"->"branch",
    "CommitSHA"->"sha"
    };


Options[GitHubDeleteFile]=
  Join[
    Thread[Keys[$GitHubParamMap[GitHubDeleteFile]]->Automatic],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubDeleteFile[
  repo:(_String|_GitHubPath)?GitHubRepoQ,
  path_String,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"contents", path},
    <|
      Method->"DELETE",
      "Body"->
        GitHubQueryParamFilter[
          GitHubDeleteFile,
          {
            "CommitSHA"->
              Replace[OptionValue["CommitSHA"],
                Except[_String]:>
                  GitHubGetFileSHA[repo, path]
                ],
            ops,
            "Message"->TemplateApply["Removed ``", path]
            }
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
            }
      |>
    ];


(* ::Subsection:: *)
(* Releases*)



(* ::Subsubsection::Closed:: *)
(*Releases*)



GitHubReleases//Clear


GitHubReleases[
  repo:(_GitHubPath|_String)?GitHubRepoQ,
  identifier:_String|_Integer|None:None
  ]:=
  GitHubReposAPI[
    repo,
    Switch[identifier,
      None,
        "releases",
      _Integer|_?(StringMatchQ[ToLowerCase@#,"latest"]&),
        {"releases", ToLowerCase@ToString@identifier},
      _,
        {"releases", "tags", ToLowerCase@ToString@identifier}
      ]
    ];
GitHubReleases[
  repo:(_GitHubPath|_String)?(GitHubReleaseQ),
  identifier:_:None
  ]:=
  Replace[
    Replace[repo, s_String:>GitHubPath[s]],
    {
      GitHubPath[s__, "releases", "tag", tag_String,o__?OptionQ]:>
        GitHubReleases[GitHubPath[s, o], tag],
      GitHubPath[s__, "releases", "latest", o__?OptionQ]:>
        GitHubReleases[GitHubPath[s, o], "latest"],
      GitHubPath[s__, "releases", o__?OptionQ]:>
        GitHubReleases[GitHubPath[s, o], identifier]
      }
    ]


(* ::Subsubsection::Closed:: *)
(*GetRelease*)



$GitHubActions["GetRelease"]=GitHubGetRelease;


GitHubGetRelease//Clear


GitHubGetRelease[
  repo_String,
  tagName:_Integer|"latest":"latest",
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"releases", ToString@tagName}
    ]


(* ::Subsubsection::Closed:: *)
(*CreateRelease*)



$GitHubActions["CreateRelease"]=GitHubCreateRelease;


$GitHubParamMap[GitHubCreateRelease]=
  {
    "Name"->"name",
    "TagName"->"tag_name",
    "TargetCommitish"->"target_commitish",
    "Description"->"body",
    "Draft"->"draft",
    "PreRelease"->"prerelease"
    };


Options[GitHubCreateRelease]=
  Join[
    FilterRules[
      Thread[Keys[$GitHubParamMap[GitHubCreateRelease]]->Automatic],
      Except["TagName"]
      ],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubCreateRelease[
  repo_String,
  tagName_String,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"releases"},
    <|
      "Method"->"POST",
      "Body"->
      ExportString[
          GitHubQueryParamFilter[
            GitHubCreateRelease,
            {
              "TagName"->tagName,
              ops
              }
            ],
          "JSON"
          ],
      "Headers"->
        {
          "Authorization"->
            OptionValue[{"Username", "Password"}]
          }
      |>
      ]


(* ::Subsubsection::Closed:: *)
(*EditRelease*)



$GitHubActions["EditRelease"]=GitHubEditRelease;


$GitHubParamMap[GitHubEditRelease]=
  {
    "Name"->"name",
    "TagName"->"tag_name",
    "TargetCommitish"->"target_commitish",
    "Description"->"body",
    "Draft"->"draft",
    "PreRelease"->"prerelease"
    };


GitHubEditRelease//Clear


Options[GitHubEditRelease]=
  Join[
    Thread[Keys[$GitHubParamMap[GitHubEditRelease]]->Automatic],
    {
      "Username"->Automatic,
      "Password"->Automatic
      }
    ];
GitHubEditRelease[
  repo_String,
  id_Integer,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"releases", ToString@id},
    <|
      "Method"->"PATCH",
      "Body"->
        ExportString[
          GitHubQueryParamFilter[
            GitHubCreateRelease,
            {
              ops
              }
            ],
          "JSON"
          ],
      "Headers"->{
        "Authorization"->
          OptionValue[{"Username", "Password"}]
          }
      |>
    ];


(* ::Subsubsection::Closed:: *)
(*DeleteRelease*)



$GitHubActions["DeleteRelease"]=GitHubDeleteRelease;


GitHubDeleteRelease//Clear


Options[GitHubDeleteRelease]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubDeleteRelease[
  repo_String,
  id_Integer,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"releases", ToString@id},
    <|
      "Method"->"DELETE",
      "Headers"->{
        "Authorization"->
          OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*ListReleaseAssets*)



$GitHubActions["ListReleaseAssets"]=GitHubListReleaseAssets;


Options[GitHubListReleaseAssets]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubListReleaseAssets[
  repo_String,
  id_Integer,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"releases", ToString@id, "assets"},
    <|
      "Method"->"GET",
      "Headers"->{
        "Authorization"->
          OptionValue[{"Username", "Password"}]
          }
      |>
    ];


(* ::Subsubsection::Closed:: *)
(*UploadReleaseAsset*)



$GitHubActions["UploadReleaseAsset"]=GitHubUploadReleaseAsset;


$GitHubParamMap[GitHubUploadReleaseAsset]=
  {
    "Name"->Automatic,
    "Label"->Automatic
    };


GitHubUploadReleaseAsset//Clear


Options[GitHubUploadReleaseAsset]=
  {
    "Username"->Automatic,
    "Password"->Automatic,
    "ContentType"->Automatic,
    "Name"->Automatic,
    "Label"->Automatic
    };
GitHubUploadReleaseAsset[
  repo_String,
  id_Integer,
  asset:(_String|_File)?FileExistsQ|_ByteArray,
  ops:OptionsPattern[]
  ]:=
  Block[
    {
      $GitHubQueryBase=
        ReplacePart[$GitHubQueryBase, "Domain"->"uploads.github.com"],
      $GitHubBodyFormat="Binary"
      },
    GitHubReposAPI[
      repo,
      {"releases", ToString@id, "assets"},
      {
        Replace[OptionValue["Name"],
          {
            s_String:>
              ("name"->s),
            _:>
              ("name"->FileNameTake[asset])
            }
          ],
        Replace[OptionValue["Label"],
          {
            s_String:>
              ("label"->s),
            _:>
              Nothing
            }
          ]
        },
      <|
        "Method"->"POST",
        "Body"->
          Replace[
            asset,
            _String|_File:>
              Flatten[File[asset], 1, File]
            ],
        "Headers"->{
          Replace[OptionValue["ContentType"],
            {
              s_String:>
                "ContentType"->s,
              _->Nothing
              }
            ],
          "Authorization"->
            OptionValue[{"Username", "Password"}]
            }
        |>
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*GetReleaseAsset*)



Options[GitHubGetReleaseAsset]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubGetReleaseAsset[
  repo_String,
  id_Integer,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"releases", "assets", ToString@id},
    <|
      "Method"->"GET",
      "Headers"->{
        "Authorization"->
          OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsubsection::Closed:: *)
(*EditReleaseAsset*)



$GitHubActions["EditReleaseAsset"]=GitHubEditReleaseAsset;


$GitHubParamMap[GitHubEditReleaseAsset]=
  {
    "Name"->Automatic,
    "Label"->Automatic
    };


Options[GitHubEditReleaseAsset]=
  {
    "Username"->Automatic,
    "Password"->Automatic,
    "Name"->Automatic,
    "Label"->Automatic
    };
GitHubEditReleaseAsset[
  repo_String,
  id_Integer,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"releases", "assets", ToString@id},
    <|
      "Method"->"PATCH",
      "Body"->
        ExportString[
          GitHubQueryParamFilter[
            GitHubEditReleaseAsset,
            {
              ops
              }
            ],
          "JSON"
          ],
      "Headers"->{
        "Authorization"->
          OptionValue[{"Username", "Password"}]
          }
      |>
    ];


(* ::Subsubsection::Closed:: *)
(*DeleteReleaseAsset*)



$GitHubActions["DeleteReleaseAsset"]=GitHubDeleteReleaseAsset;


Options[GitHubDeleteReleaseAsset]=
  {
    "Username"->Automatic,
    "Password"->Automatic
    };
GitHubDeleteReleaseAsset[
  repo_String,
  id_Integer,
  ops:OptionsPattern[]
  ]:=
  GitHubReposAPI[
    repo,
    {"releases", "assets", ToString@id},
    <|
      "Method"->"DELETE",
      "Headers"->{
        "Authorization"->
          OptionValue[{"Username", "Password"}]
          }
      |>
    ]


(* ::Subsection:: *)
(*Deployments*)



(* ::Subsubsection::Closed:: *)
(*Deployments*)



GitHubDeployments[repo:(_GitHubRepo|_String)?GitHubRepoQ,
  identifier:_String|_Integer|None
  ]:=
  GitHubReposAPI[repo,
    If[identifier===None,
      "deployments",
      {"deployments",ToLowerCase@ToString@identifier}
      ]
    ];


(* ::Subsection:: *)
(*Helpers*)



(* ::Subsubsection::Closed:: *)
(*GitHubClone *)



GitHubClone//Clear


Options[GitHubClone]:=
  Join[
    Options[GitHubPath],
    {
      OverwriteTarget->False
      },
    Git["Clone", "Options"]
    ];
GitHubClone[
  repo:(_String|_GitHubPath)?(Not@*GitHubReleaseQ),
  dir:(_String?(DirectoryQ@*DirectoryName))|Automatic:Automatic,
  ops:OptionsPattern[]
  ]:=
  Module[
    {
      path=
        If[MatchQ[repo, _GitHubPath],
          repo,
          GitHubPath[repo, FilterRules[{ops}, Options@GitHubPath]]
          ]
      },
    With[
      {
        o=Options[path],
        n=Normal[path]
        },
      Switch[Lookup[o, "Tree", "tree"],
        "tree",
          If[Length@n<3,
            GitClone[
              URL[path],
              dir,
              OverwriteTarget->OptionValue[OverwriteTarget],
              ops
              ],
            SVNExport[
              URL[GitHubPath[repo, "Tree"->"trunk", "Branch"->Nothing]],
              dir,
              "TrustServer"->True,
              OverwriteTarget->OptionValue[OverwriteTarget]
              ]
            ],
        "trunk",
          SVNExport[
            URL[path],
            dir,
            "TrustServer"->True,
            OverwriteTarget->OptionValue[OverwriteTarget]
            ],
        "raw"|"releases",
          Replace[
            URLDownload[
              URL[path],
              FileNameJoin@{
                If[StringQ@dir, 
                  If[!DirectoryQ@dir, CreateDirectory[dir]];
                  dir,
                  $TemporaryDirectory
                  ], 
                Last@n
                }
              ],
            File[f_]:>f
            ],
        _,
          GitHub::badtree=
            "Don't know what to do with tree type ``";
          Message[GitHub::badtree,
            Lookup[o, "Tree", "tree"]
            ];
          $Failed
        ]
      ]/;path=!=$Failed
    ];
GitHubClone[
  repo:(_String|_GitHubPath)?GitHubReleaseQ,
  dir:(_String?(DirectoryQ@*DirectoryName))|Automatic:Automatic,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      release=
        GitHub[
          "Releases",
          GitHubPath[repo],
          "ImportedResult"
          ]["Content"]
      },
    If[AssociationQ@release,
      If[Length@release["Assets"]>0,
        With[{url=
          release[["Assets",-1,"BrowserDownloadURL"]]
          },
          URLDownload[
            url,
            FileNameJoin@{
              Replace[dir, 
                {
                  Automatic:>$TemporaryDirectory,
                  _:>(If[!DirectoryQ@dir, CreateDirectory[dir]];dir)
                  }
                ],
              URLParse[url,"Path"][[-1]]
              }
            ]
          ],
        ExtractArchive[
          URLDownload[
            release["ZipballURL"],
            FileNameJoin@{
              $TemporaryDirectory,
              URLParse[release["ZipballURL"],"Path"][[-1]]
              }
            ],
          Replace[dir, 
            {
              Automatic:>$TemporaryDirectory,
              _:>(If[!DirectoryQ@dir, CreateDirectory[dir]];dir)
              }
            ]
          ]
        ],
      $Failed
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*GitHubConfigure*)



GitHubConfigure[
  dirBase:_String?DirectoryQ|Automatic,
  repo:_String?GitHubRepoQ|_GitHubPath,
  ignorePats:{___String}|None:None,
  excludePats:{___String}|None:None
  ]:=
  Module[{repoExistsQ, dir=Replace[dirBase, Automatic:>Directory[]]},
    If[!GitRepoQ@dir,
      GitInit[dir, ignorePats, excludePats];
      GitSetRemote[dir, repo];
      repoExistsQ=Between[URLRead[repo,"StatusCode"],{200,299}];
      If[repoExistsQ, GitRealignRemotes[dir]]
      ];
    If[GitRepoQ@dir,
      If[!ValueQ[repoExistsQ],
        repoExistsQ=Between[URLRead[repo,"StatusCode"],{200,299}]
        ];
      If[!repoExistsQ,
        GitHubImport["Create",
          URLParse[repo, "Path"][[-1]]
          ];
        GitSetRemote[dir, repo]
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*GitHubPush*)



Options[GitHubPush]=
  {
    "IncludePassword"->Automatic
    };
GitHubPush[
  dir:_String?GitRepoQ,
  repo:_String|_GitHubPath|Automatic:Automatic,
  ops:OptionsPattern[]
  ]:=
  Block[
    {
      $GitHubEncodePassword=
        Replace[OptionValue["IncludePassword"],
          Except[True|False]:>$GitHubEncodePassword
          ]
      },
    Replace[repo,{
      Automatic:>
        Replace[
          GitGetRemoteURL[dir, "PushURL"->True],
          {
            s_String:>
              Git["Push", dir, s],
            (r_->s_):>
              Quiet@
                Check[
                  Git["Push", dir, r, "master"],
                  Git["Push", s]
                  ]
            }
          ],
      s_String?(URLParse[#, "Scheme"]===None&):>
        Quiet@
          Check[
            Git["Push", dir, s, "master"],
            Git["Push", dir, URL@GitHubPath[s]]
            ],
      s_String:>
        Git["Push", dir, s]
      }]
    ]


(* ::Subsubsection::Closed:: *)
(*GitHubImport*)



GitHubImport//Clear


GitHubImport[a_Association]:=
  Association@
    KeyValueMap[
      StringReplace[
        StringJoin[
          Replace[
            HoldPattern[Capitalize[s_String]]:>
              (ToUpperCase@StringTake[s,1]<>StringDrop[s,1])
            ]@*Capitalize/@StringSplit[#,"_"]
          ],{
        "Id"~~EndOfString->"ID",
        "Url"->"URL",
        "Html"->"HTML",
        "Sha"->"SHA"
        }]->
        Which[
          StringEndsQ[#,"_at"],
            DateObject@#2,
          StringEndsQ[#,"url"],
            URL[#2],
          True,
            GitHubImport@#2
          ]&,
    a
    ];
GitHubImport[h_HTTPResponse]:=
  <|
    "StatusCode"->
      h["StatusCode"],
    "Content"->
      If[MatchQ[h["StatusCode"],0|(_?(Between@{200,299}))],
        Quiet[
          Check[
            GitHubImport@Import[h, "RawJSON"],
            Null,
            Import::jsonnullinput
            ],
          Import::jsonnullinput
          ],
        $Failed
        ],
    If[h["StatusCode"]>400,
      "Message"->Import[h, "RawJSON"]["message"],
      Nothing
      ]
    |>;
GitHubImport[s_String]:=
  s;
GitHubImport[l_List]:=
  GitHubImport/@l;
GitHubImport[e_]:=
  e


GitHubImport[
  command_?(MemberQ[ToLowerCase/@Keys[$GitHubActions], ToLowerCase@#]&),
  args__
  ]:=
  With[{gh=GitHub[command,args]},
    GitHubImport[gh]/;Head[gh]=!=GitHub
    ]
GitHubImport[
  path:{___String}|_String:{},
  query:(_String->_)|{(_String->_)...}:{},
  headers:_Association:<||>
  ]:=
  With[{gh=GitHub[path,query,headers]},
    GitHubImport[gh]/;Head[gh]=!=GitHub
    ]


(* ::Subsection:: *)
(*Actions*)



(* ::Subsubsection::Closed:: *)
(*Actions*)



$GitHubActions=
  KeySort@
    Join[
      $GitHubActions,
      <|
        "Push"->
          GitHubPush,
        "Configure"->
          GitHubConfigure,
        "Repositories"->
          GitHubRepositories,
        "ListMyRepositories"->
          GitHubListMyRepositories,
        "Clone"->
          GitHubClone,
        "ListContributors"->
          GitHubRepositoryContributors,
        "ListBranches"->
          GitHubRepositoryBranches,
        "BranchInfo"->
          GitHubRepositoryBranchInfo,
        "Fork"->
          GitHubFork,
        "ListForks"->
          GitHubListForks,
        "CreateReadme"->
          GitHubCreateReadme,
        "GetReadme"->
          GitHubGetReadme,
        "GetFile"->
          GitHubGetFile,
        "AddFile"->
          GitHubAddFile,
        "DeleteFile"->
          GitHubDeleteFile,
        "Releases"->
          GitHubReleases,
        "CreateRelease"->
          GitHubCreateRelease,
        "EditRelease"->
          GitHubEditRelease,
        "DeleteRelease"->
          GitHubDeleteRelease,
        "UploadReleaseAsset"->
          GitHubUploadReleaseAsset,
        "GetReleaseAsset"->
          GitHubGetReleaseAsset,
        "EditReleaseAsset"->
          GitHubEditReleaseAsset,
        "DeleteReleaseAsset"->
          GitHubDeleteReleaseAsset,
        "Deployments"->
          GitHubDownloads,
        "Path"->
          Function[GitHubPath[##]],
        "URL"->
          Function[
            Replace[GitHubPath[##],
              g_GitHubPath:>URL[g]
              ]
            ],
        "RawPath"->
          Function[GitHubPath[##, "Tree"->"raw"]],
        "RawURL"->
          Function[
            Replace[GitHubPath[##, "Tree"->"raw"],
              g_GitHubPath:>URL[g]
              ]
            ],
        "SVNPath"->
          Function[GitHubPath[##, "Tree"->"trunk", "Branch"->Nothing]],
        "SVNURL"->
          Function[
            Replace[GitHubPath[##, "Tree"->"trunk", "Branch"->Nothing],
              g_GitHubPath:>URL[g]
              ]
            ],
        "PathQ"->
          GitHubPathQ,
        "RepoQ"->
          GitHubRepoQ,
        "ReleaseQ"->
          GitHubReleaseQ
        |>
        ];


End[];



