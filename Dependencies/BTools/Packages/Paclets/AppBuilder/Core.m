(* ::Package:: *)

(* Autogenerated Package *)

(* ::Text:: *)
(*AppBuilding utilities, pushed into a lower-context*)



(* ::Subsubsection::Closed:: *)
(*Methods*)



$AppExecuteMethods::usage=
  "The set of methods known to AppExecute";
$AppDocGenMethodRouter::usage=
  "The set of methods known to AppDocGen";
$AppGitRouter::usage=
  "The set of methods known to AppGit";
$AppPacletExecuteMethods::usage=
  "The set of methods known to AppPacletExecute";


(* ::Subsubsection::Closed:: *)
(*Find*)



$AppPathMap::usage="";
AppNames::usage="Finds the names of apps matching a pattern";
AppLocate::usage="Locates an app";
AppPathFormat::usage="";
AppFileNames::usage="FileNames on an app";


AppComponentFiles::usage="";
AppPackages::usage=
  "Finds the packages in a given app";
AppStyleSheets::usage="";
AppPalettes::usage=""
AppSymbolPages::usage="";
AppGuides::usage="";
AppTutorials::usage="";


AppPacletContexts::usage="";
AppMainContext::usage="";
AppContexts::usage="";


AppFindFile::usage="";
AppPackage::usage="";
AppStylesheet::usage="";
AppSymbolPage::usage="";
AppGuidePages::usage="";


AppDirectory::usage=
  "Used by AppPath find appropriate directories"


(* ::Subsubsection::Closed:: *)
(*Edit*)



AppAddPackage::usage="Adds a package";
AppAddPalette::usage="Adds a palette to the app";
AppAddStylesheet::usage="Adds a stylesheet to the app";
AppAddDocPage::usage="Adds a doc page for a symbol to the app";
AppAddGuidePage::usage="Adds a guide to the app";
AppAddTutorialPage::usage="Adds a tutorial page to the app";


AppRegenerateDirectories::usage=
  "Regenerates missing directories in the app";
AppRegenerateContextLoadFiles::usage=
  "Regenerates missing contex loader files in the app";
AppRegenerateInit::usage=
  "Regenerates a default init file";
AppRegenerateDocInfo::usage=
  "Regenerates the DocInfo.m file";
AppRegenerateBundleInfo::usage=
  "Regenerates the BundleInfo file";
AppRegenerateLoadInfo::usage=
  "Regenerates the LoadInfo file";
AppRegenerateGitIgnore::usage=
  "Rebuilds the .gitignore file";
AppRegenerateGitExclude::usage=
  "Rebuilds the .git/info/exclude file";
AppRegenerateReadme::usage=
  "Generates a GitHub README.md file for the app";
AppRegenerateUploadInfo::usage=
  "Regenerates the UploadInfo.m file";


AppBundleDependency::usage=
  "Bundles a dependency into the app";
AppAddDependency::usage=
  "Adds a dependency to the app";
AppUpdateDependencies::usage=
  "...";


(* ::Subsubsection::Closed:: *)
(*Analyze*)



AppGenerateTestingNotebook::usage=
  "Generates a standard testing notebook for an app";


AppPackageFunctions::usage=
  "Gets the function names declared in a package or set of packages";
AppFunctionDependencies::usage=
  "Gets the package dependency chain for a function";
AppPackageDependencies::usage=
  "Gets the dependency structure for a full app package";


(* ::Subsubsection::Closed:: *)
(*Distribute*)



(*PackageScopeBlock[
	AppBundle::usage="Creates a sync bunde for an app";
	AppUpload::usage="Uploads an application zip to the cloud";
	AppDownload::usage="Downloads an app into a directory";
	AppInstall::usage="Downloads/installs an application";
	AppBackup::usage="Backs up the app";
	AppBackups::usage="Gets all the backed-up versions of the app";
	AppRestore::usage="Restores the most recent version of the app";
	]*)


(* ::Subsubsection::Closed:: *)
(*Project*)



(*PackageScopeBlock[
	AppDeployReadme::usage=
		"Deploys the app README.md file";
	AppDeployHTML::usage=
		"Deploys app HTML files";
	AppDeployImages::usage=
		"Deploys the app img files";
	AppDeployCSS::usage=
		"Deploys the app css files";
	]*)


Begin["`Private`"];


(* ::Subsection:: *)
(*Find*)



(* ::Subsubsection::Closed:: *)
(*AppPathFormat*)



$AppPathMap=
  {
      "Packages"->{"Packages"},
      "Resources"->{"Resources"},
      "Palettes"->{"FrontEnd","Palettes"},
      "StyleSheets"->{"FrontEnd","StyleSheets"},
      "TextResources"->{"FrontEnd","TextResources"},
      "SystemResources"->{"FrontEnd","SystemResources"},
      "Guides"->{"Documentation","English","Guides"},
      "Tutorials"->{"Documentation", "English","Tutorials"},
      "ReferencePages"->{"Documentation","English","ReferencePages"},
      "Symbols"->{"Documentation", "English","ReferencePages","Symbols"},
      "SymbolPages"->{"Documentation", "English","ReferencePages","Symbols"},
      "MessagePages"->{"Documentation", "English","ReferencePages","Messages"},
      "Objects"->{"Resources", "Objects"},
      "Private"->{"Private"}
      };


AppPathFormat[pspec_]:=
  Replace[
    Flatten[{pspec}, 1],
    $AppPathMap,
    1]


(* ::Subsubsection::Closed:: *)
(*AppNames*)



AppNames//Clear
AppNames[
  pat:
    _?StringPattern`StringPatternQ|
      {__?StringPattern`StringPatternQ}:WordCharacter..,
  baseName:True|False:True,
  first:True|False:False
  ]:=
  If[
    first&&StringQ@pat&&DirectoryQ@pat&&
      FileExistsQ@FileNameJoin[{pat, "PacletInfo.m"}],
    If[baseName, FileBaseName, Identity]@
      pat,
    If[first, 
      Identity,
      DeleteDuplicates@*
        If[baseName, Map[FileBaseName], Identity]
      ]@If[first, SelectFirst, Select][
        FileExistsQ@FileNameJoin[{#, "PacletInfo.m"}]&
        ]@
        DeleteDuplicates@
          Join[
            Select[Flatten@{pat}, StringQ],
            FileNames[pat, $AppDirectory],
            FileNames[pat, $AppDirectories]
            ]
  ];


(* ::Subsubsection::Closed:: *)
(*AppLocate*)



AppLocate[app_]:=
  Replace[
    AppNames[app, False, True], 
    {
      f_String:>f,
      {
        f_,
        ___
        }:>f,
      _->$Failed
      }
    ]


(* ::Subsubsection::Closed:: *)
(*AppFileNames*)



Options[AppFileNames]=
  Join[
    Options[FileNames],
    {
      "DropDirectory"->True,
      Select->Automatic
      }
    ];
AppFileNames[
  app:_String|Automatic,
  p___String,
  pat:_?StringPattern`StringPatternQ:"*",
  depth:_Integer?Positive|Infinity:1,
  ops:OptionsPattern[]
  ]:=
  With[{d=AppPath[app, p], sel=OptionValue[Select]},
    If[TrueQ@OptionValue["DropDirectory"],
      Map[FileNameDrop[#, FileNameDepth[d]]&],
      Identity
      ]@
      If[sel=!=Automatic, 
        Select[TrueQ@sel[#]&], 
        Identity
        ]@
      FileNames[pat, d, depth,
        FilterRules[{ops}, Options@FileNames]
        ]
    ]


(* ::Subsubsection::Closed:: *)
(*AppComponentFiles*)



Options[AppComponentFiles]=
  Join[
    {
      "DropExtension"->Automatic
      },
    Options[AppFileNames]
    ];
AppComponentFiles[
  app:_String,
  path___String,
  ext:
    Except[
      "Palettes"|"Packages"|"StyleSheets"|
        "SymbolPages"|"Guides"|"Tutorials",
      _?StringPattern`StringPatternQ
      ],
  o:OptionsPattern[]
  ]:=
  If[TrueQ@OptionValue["DropExtension"]||
    (OptionValue["DropExtension"]=!=False&&OptionValue["DropDirectory"]=!=False),
    StringTrim[#, "."~~ext],
    #
    ]&@
    AppFileNames[
      app,
      path,
      __~~"."~~ext,
      Infinity,
      IgnoreCase->True,
      FilterRules[{o}, Options[AppFileNames]]
      ]  


AppComponentFiles[app_String, "Packages", ops:OptionsPattern[]]:=
  AppComponentFiles[app, "Packages", "m"|"wl", ops];
AppComponentFiles[app_String, "Palettes", ops:OptionsPattern[]]:=
  AppComponentFiles[app, "Palettes", "nb", ops];
AppComponentFiles[app_String, "StyleSheets", ops:OptionsPattern[]]:=
  AppComponentFiles[app, "StyleSheets", "nb", ops];
AppComponentFiles[app_String, "SymbolPages", ops:OptionsPattern[]]:=
  AppComponentFiles[app, "SymbolPages", "nb", ops];
AppComponentFiles[app_String, "Guides", ops:OptionsPattern[]]:=
  AppComponentFiles[app, "Guides", "nb", ops];
AppComponentFiles[app_String, "Tutorials", ops:OptionsPattern[]]:=
  AppComponentFiles[app, "Tutorials", "nb", ops];


(* ::Subsubsection::Closed:: *)
(*AppPackages*)



Options[AppPackages]=
  Options[AppComponentFiles]
AppPackages[
  app:_String,
  ops:OptionsPattern[]
  ]:=
  Select[
    AppComponentFiles[app, "Packages", "m"|"wl", ops],
    StringFreeQ["__"]
    ]


(* ::Subsubsection::Closed:: *)
(*AppPacletContexts*)



AppPacletContexts[app_]:=
  With[{pi=AppPacletInfo[app]},
    Replace[
      Fold[
        Lookup[##, <||>]&,
        If[AssociationQ@pi, pi, <||>],
        {"Extensions", "Kernel", "Context"}
        ],
      {
        Except[{__String}]:>{}
        }
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*AppContext*)



AppMainContext[app_]:=
  Replace[
    AppPacletContexts[app],
    {
      {s_String, ___}:>s,
      _:>AppFromFile[app]<>"`"
      }
    ]


(* ::Subsubsection::Closed:: *)
(*AppContexts*)



AppContexts//Clear


Options[AppContexts]=
  {
    "FullContext"->True
    };
AppContexts[
  app:_String,
  ops:OptionsPattern[]
  ]:=
  With[
    {
      subconts=
        StringReplace[
          AppFileNames[app, 
            "Packages", 
            WordCharacter..,
            Infinity,
            "DropDirectory"->True,
            Select->DirectoryQ
            ],
          $PathnameSeparator->"`"
          ]
      },
    If[Length@subconts==0,
      If[!TrueQ@OptionValue["FullContext"], 
        DeleteCases[""]@StringTrim[#, AppMainContext[app]]&, 
        Identity
        ]@
        AppPacletContexts[app],
      If[TrueQ@OptionValue["FullContext"],
        With[{mc=AppMainContext[app]},
          Prepend[Map[mc<>#<>"`"&, subconts], mc]
          ],
        #<>"`"&/@subconts
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*AppStyleSheets*)



Options[AppStyleSheets]=
  Options[AppComponentFiles]
AppStyleSheets[
  app:_String,
  ops:OptionsPattern[]
  ]:=
  AppComponentFiles[app, "StyleSheets", "nb", ops]


(* ::Subsubsection::Closed:: *)
(*AppPalettes*)



Options[AppPalettes]=
  Options[AppComponentFiles]
AppPalettes[
  app:_String,
  ops:OptionsPattern[]
  ]:=
  AppComponentFiles[app, "Palettes", "nb", ops]


(* ::Subsubsection::Closed:: *)
(*AppSymbolPages*)



Options[AppSymbolPages]=
  Options[AppComponentFiles]
AppSymbolPages[
  app:_String,
  ops:OptionsPattern[]
  ]:=
  AppComponentFiles[app, "SymbolPages", "nb", ops]


(* ::Subsubsection::Closed:: *)
(*AppGuides*)



Options[AppGuides]=
  Options[AppComponentFiles]
AppGuides[
  app:_String,
  ops:OptionsPattern[]
  ]:=
  AppComponentFiles[app, "Guides", "nb", ops]


(* ::Subsubsection::Closed:: *)
(*AppTutorials*)



Options[AppTutorials]=
  Options[AppComponentFiles]
AppTutorials[
  app:_String,
  ops:OptionsPattern[]
  ]:=
  AppComponentFiles[app, "Tutorials", "nb", ops]


(* ::Subsubsection::Closed:: *)
(*AppFindFile*)



AppFindFile[app_, path__String, exts_]:=
  Replace[
    AppPath[app, path],{
      f_?(FileExistsQ[#]&&!DirectoryQ[#]&):>
        f,
      f_:>
        If[FileExtension@f==="",
          SelectFirst[f<>#&/@exts,
            FileExistsQ
            ],
          Missing["NotFound"]
          ]
      }]


(* ::Subsubsection::Closed:: *)
(*AppPackage*)



AppPackage[app_, pkg_String]:=
  AppFindFile[app, "Packages", pkg, {".nb", ".m", ".wl"}]


(* ::Subsubsection::Closed:: *)
(*AppStylesheet*)



AppStylesheet[app_, pkg_String]:=
  AppFindFile[app, "Stylesheet", pkg, {".nb"}]


(* ::Subsubsection::Closed:: *)
(*AppPalette*)



AppPalette[app_, pkg_String]:=
  AppFindFile[app, "Palette", pkg, {".nb"}]


(* ::Subsubsection::Closed:: *)
(*AppSymbolPage*)



AppSymbolPage[app_, pkg_String]:=
  AppFindFile[app, "Symbols", pkg, {".nb"}]


(* ::Subsubsection::Closed:: *)
(*AppGuidePage*)



AppSymbolPage[app_, pkg_String]:=
  AppFindFile[app, "Guides", pkg, {".nb"}]


(* ::Subsubsection::Closed:: *)
(*AppTutorialPage*)



AppSymbolPage[app_, pkg_String]:=
  AppFindFile[app, "Tutorials", pkg, {".nb"}]


(* ::Subsection:: *)
(*Builder*)



(* ::Subsubsection::Closed:: *)
(*AppDirectory*)



AppDirectory[app_, extensions___]:=
  FileNameJoin@
    Flatten@
      {
        Replace[
          AppLocate[app],
          $Failed:>
            {
              $AppDirectory,
              app
              }
          ],
        AppPathFormat@{extensions}
        };


(* ::Subsubsection::Closed:: *)
(*InitTemplates*)



(* ::Subsubsubsection::Closed:: *)
(*cleanInitTemplate*)



cleanInitTemplate[file_]:=
  StringReplace[
    StringReplace[
      StringTrim[
        Import[file, "Text"],
        Verbatim["(* ::Package:: *)\n\n"]
        ],
      "`"->"`tick`"
      ],
    {
      "$InitCode"->"`cores`",
      "$Name"->"`name`"
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*applyInitTemplate*)



applyInitTemplate[template_, pkg_]:=
  TemplateApply[
    template,
    <|
      "name"->pkg,
      "tick"->"`"
      |>
    ]


(* ::Subsubsubsection::Closed:: *)
(*$appInitStrings*)



$appInitStrings:=
  Association[
    FileBaseName[#]->
      cleanInitTemplate[#]&/@
        FileNames[
          "*.wl",
          PackageFilePath[
            "Resources",
            "Templates",
            "Initialization",
            "Loader"
            ]
          ]
      ]


(* ::Subsubsubsection::Closed:: *)
(*appInitTemplate*)



$appInitComponents=
  {
    "Constants", "Paths", "Usages", "Loading",
    "Dependencies", "Exceptions", "Autocomplete",
    "FrontEnd"
    }


appInitTemplate[pkg_]:=
  With[{strings=$appInitStrings},
    applyInitTemplate[
      TemplateApply[strings["MainLoader"],<|
        "cores"->
          StringRiffle[
            StringTrim@Lookup[strings, $appInitComponents],
            "\n"
            ],
        "tick"->"`tick`",
        "name"->"`name`"
        |>],
      pkg
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*AppRegenerateInit*)



AppRegenerateInit[name_String]:=
  With[{
    packageGet=
      applyInitTemplate[
        cleanInitTemplate@
          PackageFilePath[
            "Resources",
            "Templates",
            "Initialization",
            "init.m"
            ],
        name
        ],
    loaderGet=
      applyInitTemplate[
        cleanInitTemplate@
          PackageFilePath[
            "Resources",
            "Templates",
            "Initialization",
            "Main.wl"
            ],
        name
        ],
    loader=AppDirectory[name,name<>"Loader.wl"],
    pkg=AppDirectory[name,name<>".wl"],
    init=AppDirectory[name,"Kernel","init.m"]
    },
    Export[loader,appInitTemplate[name],"Text"];
    Export[init, packageGet, "Text"];
    Export[pkg, loaderGet, "Text"]
    ];


(* ::Subsubsection::Closed:: *)
(*AppRegenerateUploadInfo*)



Options[AppRegenerateUploadInfo]=
  Join[
    Options@AppPacletSiteURL,
    Options@AppPacletSiteMZ
    ];
AppRegenerateUploadInfo[app_String,ops:OptionsPattern[]]:=
  (
    If[!DirectoryQ@AppPath[app,"Config"], CreateDirectory[AppPath[app,"Config"]]];
    Export[
      AppPath[app,"Config","UploadInfo.m"],
      Flatten@{
        ops,
        "ServerName"->
          Automatic,
        CloudConnect->
          False
        }]
    );


(* ::Subsection:: *)
(*Edit*)



(* ::Subsubsection::Closed:: *)
(*Add Elements*)



AppAddPackage[name_,file_]:=
  AppAddContent[name,file,"Packages"];


AppAddStylesheet[name_,file_]:=
  AppAddContent[name,file,"StyleSheets"];


AppAddPalette[name_,file_]:=
  AppAddContent[name,file,"Palettes"];


AppAddDocPage[name_,file_]:=
  AppAddContent[name,file,"Symbols"];


AppAddGuidePage[name_,file_]:=
  AppAddContent[name,file,"Guides"];


AppAddTutorialPage[name_,file_]:=
  AppAddContent[name,file,"Tutorials"];


(* ::Subsubsection::Closed:: *)
(*getConfigFile*)



getConfigFile[app_, name_]:=
  SelectFirst[
    {
      AppPath[app, "Config", name<>".m"],
      AppPath[app, "Config", name<>".wl"]
      },
    FileExistsQ,
    AppPath[app, "Config", name<>".wl"]
    ]


(* ::Subsubsection::Closed:: *)
(*RegenerateBundleInfo*)



$DefaultBundleInfo=
  {
    "RemovePaths"->{
      "Private",
      "project",
      "GitHub",
      ".git"
      },
    "RemovePatterns"->{
      "Packages/*.nb",
      "Packages/*/*.nb",
      "Packages/*/*/*.nb",
      ".DS_Store",
      ".gitignore"
      }
    };


Options[AppRegenerateBundleInfo]=Options@AppPacletBundle;
AppRegenerateBundleInfo[app_String,ops:OptionsPattern[]]:=
  Export[
    getConfigFile[app, "BundleInfo"],
    DeleteDuplicatesBy[First]@Flatten@{ops, $DefaultBundleInfo}
    ];


(* ::Subsubsection::Closed:: *)
(*RegenerateLoadInfo*)



Options[AppRegenerateLoadInfo]=
  {
    "PreLoad"-> None,
    "FEHidden" -> {},
    "PackageScope"->None,
    "Mode"->"Primary",
    "Dependencies"->{}
    };
AppRegenerateLoadInfo[app_String,ops:OptionsPattern[]]:=
  (
    If[!DirectoryQ@AppPath[app,"Config"], CreateDirectory[AppPath[app,"Config"]]];
    Export[
      getConfigFile[app, "LoadInfo"],
      PrettyString@
        DeleteDuplicatesBy[First]@
          Flatten@{
            ops,
            Options@AppRegenerateLoadInfo
          },
      "Text"
      ]
    );


(* ::Subsubsection::Closed:: *)
(*RegenerateContextLoadFiles*)



AppRegenerateContextLoadFiles[app_]:=
  With[
    {
      cts=Rest@AppContexts[app, "FullContext"->True],
      ctf=
        Import[
          PackageFilePath["Resources", "Templates", "ContextLoader.wl"],
          "Text"
          ]
      },
    Map[
      With[
        {
          target=
            AppPath[app, Sequence@@{#[[;;-2]], #[[-1]]<>".wl"}&@StringSplit[#, "`"]]
          },
        Quiet@
          CreateDirectory[DirectoryName@target, CreateIntermediateDirectories->True];
        WriteString[
          target,
          StringReplace[ctf, "$ContextDepth$"->ToString[StringCount[#, "`"]-1]]
          ];
        Close[target]
        ]&,
      cts
      ]
    ]


(* ::Subsubsection::Closed:: *)
(*AppBundleDependency*)



$DefaultDepRemove=
  <|
    "RemovePaths"->{"Documentation"},
    "RemovePatterns"->{}
    |>


Options[AppBundleDependency]=
  {
    "RemovePaths"->Automatic,
    "RemovePatterns"->Automatic,
    "LoadInfo"->{}
    };
AppBundleDependency[
  name_?StringQ,
  dependency_String?DirectoryQ,
  ops:OptionsPattern[]
  ]:=
  Module[
    {
      deppath,
      rempaths,
      rempatts,
      confBase,
      newload
      },
      Quiet@CreateDirectory@AppPath[name, "Dependencies"];
      deppath=AppPath[name, "Dependencies", FileBaseName[dependency]];
      confBase=
        Replace[
          getConfigFile[deppath, "BundleInfo"],
          {
            f_String?FileExistsQ:>Get@f,
            _-><||>
            }
          ];
      rempaths=
        DeleteDuplicates@Flatten@
          Replace[
            Flatten@{
              Replace[OptionValue["RemovePaths"],
                Automatic:>
                  {
                    Lookup[confBase, "RemovePaths", ParentList],
                    ParentList
                    }
                ]
              },
            ParentList:>
              Join[
                Lookup[$DefaultBundleInfo, "RemovePaths"],
                Lookup[$DefaultDepRemove, "RemovePaths"]
                ],
            1
            ];
      rempatts=
        DeleteDuplicates@Flatten@
          Replace[
            Flatten@{
              Replace[OptionValue["RemovePatterns"],
                Automatic:>
                    {
                      Lookup[confBase, "RemovePatterns", ParentList],
                      ParentList
                      }
                ]
              },
            ParentList:>
              Join[
                Lookup[$DefaultBundleInfo, "RemovePatterns"],
                Lookup[$DefaultDepRemove, "RemovePatterns"]
                ],
            1
            ];
      PartialDirectoryCopy[
        dependency,
        deppath,
        "RemovePaths"->rempaths,
        "RemovePatterns"->rempatts
        ];
    newload=
      Merge[
        {
          Quiet@
            Replace[
              Get@
                SelectFirst[
                  {
                    AppPath[deppath, "Config", "LoadInfo.wl"],
                    AppPath[deppath, "Config", "LoadInfo.m"]
                    },
                  FileExistsQ
                  ],
              Except[_?OptionQ]->{}
              ],
          "Mode"->"Dependency",
          Quiet@
            Replace[OptionValue["LoadInfo"],
              Except[_?OptionQ]->{}
              ]
          },
        Last
        ];
    AppRegenerateLoadInfo[
      deppath, 
      Sequence@@Normal@newload
      ];
    deppath
    ];
AppBundleDependency[
  name_?StringQ,
  p_PacletManager`Paclet,
  ops:OptionsPattern[]
  ]:=
  AppBundleDependency[name, p["Location"], ops];
AppBundleDependency[
  name_?StringQ,
  n_String,
  ops:OptionsPattern[]
  ]:=
  Replace[PacletManager`PacletFind[StringSplit[n, "`"][[1]]],
    {
      {p_, ___}:>
        AppBundleDependency[name, p, ops],
      _->$Failed
      }
    ];


(* ::Subsubsection::Closed:: *)
(*AppAddDependency*)



AppAddDependency//Clear


Options[AppAddDependency]=
  Join[
    Options[AppBundleDependency],
    {
      "Bundled"->True
      }
    ];
AppAddDependency[
  name_?StringQ,
  dependency_String,
  ops:OptionsPattern[]
  ]:=
  Block[
    {
      newload,
      bund=Lookup[Select[Flatten@{ops}, OptionQ], "Bundled", True], 
      loadconf,
      deplist,
      depname
      },
  If[bund,
      AppBundleDependency[name, dependency, 
        FilterRules[{ops}, Options[AppBundleDependency]]
        ]
      ];
    loadconf=
      Association@
        Replace[Quiet@Get[getConfigFile[name, "LoadInfo"]],
          Except[_Association?AssociationQ|_List?OptionQ]->{}
          ];
    deplist=Lookup[loadconf, "Dependencies", {}];
    deplist=
      Association@
        Map[If[StringQ@#, #-><||>, #[[1]]->Association@Rest[#]]&, deplist];
    depname=
      StringSplit[FileBaseName[dependency], "-"|"`"][[1]]<>"`";
    deplist[depname]=Association[ops];
    loadconf["Dependencies"]=
      KeyValueMap[
        Prepend[Normal@#2, #]&,
        deplist
        ];
    AppRegenerateLoadInfo[name, Sequence@@Normal@loadconf]
    ];


(* ::Subsubsection::Closed:: *)
(*AppUpdateDependencies*)



AppUpdateDependencies[name_, ops:OptionsPattern[]]:=
  Module[
    {
      depPath=AppPath[name, "Dependencies"],
      depConf=
        SelectFirst[
          {
            AppPath[name, "Config", "LoadInfo.wl"],
            AppPath[name, "Config", "LoadInfo.m"]
            },
          FileExistsQ,
          None
          ],
      depNames
      },
    If[depConf=!=None,
      depNames=Lookup[Get@depConf, "Dependencies", {}],
      depNames={}
      ];
    Map[
      If[Lookup[Select[Flatten@{#}, OptionQ], "Update"]=!=False,
        AppAddDependency[name, 
          Sequence@@Flatten@{#, ops}
          ]
        ]&,
      depNames
      ];
    ]


(* ::Subsection:: *)
(*Loading*)



(* ::Subsubsection::Closed:: *)
(*AppGet*)



AppGet[appName_,pkgName_String]:=
  With[{
    app=AppFromFile[appName],
    cont=$Context
    },
    Replace[
      SortBy[StringLength]@Names[app<>"`*`PackageAppGet"],{
        {n_, ___}:>
          Replace[
            FileNames[pkgName~~".wl"|".m",
              AppPath[app,"Packages"],
              \[Infinity]
              ],
            {f_,___}:>
              ToExpression[n][ExpandFileName@f]
            ],
      _:>(
        If[DirectoryQ@AppPath[app,"Packages",pkgName],
          BeginPackage[app<>"`"];
          Begin["`"<>StringTrim[StringReplace[pkgName,$PathnameSeparator->"`"],"`"]<>"`"];
          FrontEnd`Private`GetUpdatedSymbolContexts[];
          EndPackage[],
          With[{
            pkg=
              SelectFirst[
                SortBy[FileNameDepth]@
                  FileNames[
                    StringTrim[pkgName,".m"]<>".m",
                    AppPath[app,"Packages"],
                    Infinity
                    ],
                FileExistsQ
                ]
            },
            If[FileExistsQ@pkg,
              With[{
                pkCont=
                  StringReplace[
                    app<>"`"<>
                      StringReplace[
                        FileNameDrop[DirectoryName@pkg,
                          FileNameDepth@AppDirectory[app,"Packages"]],
                        $PathnameSeparator->"`"
                        ]<>"`",
                    "``"->"`"
                    ]
                },
                BeginPackage[pkCont]
                ];
              $ContextPath=
                DeleteDuplicates@
                  Join[
                    Replace[
                      ToExpression[
                        $Context<>"PackageScope`Private`$PackageContexts"
                        ],
                      Except[{__String}]->{}
                      ],
                    $ContextPath
                    ];
              CheckAbort[
                Get@pkg;
                EndPackage[],
                EndPackage[];
                Catch[
                  Catch[
                    Do[
                      If[i<100,
                        If[$Context===cont,Throw[$Context,"success"],End[]],
                        Throw[$Failed,"fail"]
                        ],
                      {i,1000}
                      ],
                    "fail",
                    Begin[cont]&
                    ],
                  "success"
                  ];
                ]
              ]
            ]
          ];
        Catch[
          Catch[
            Do[
              If[i<100,
                If[$Context===cont, Throw[$Context,"success"],End[]],
                Throw[$Failed,"fail"]
                ],
              {i,1000}
              ],
            "fail",
            Begin[cont]&
            ],
          "success"
          ]
        )
    }]
  ];
AppGet[appName_,pkgName:{__String}]:=
  AppGet[appName,FileNameJoin@pkgName];
AppGet[appName_,Optional[Automatic,Automatic]]:=
  AppGet[appName,FileBaseName@NotebookFileName[]];
AppGet[Optional[Automatic,Automatic]]:=
  With[{app=FileNameTake[NotebookFileName[],{FileNameDepth@$AppDirectory+1}]},
    AppGet[app,Automatic]
    ];


(* ::Subsubsection::Closed:: *)
(*AppNeeds*)



If[Not@AssociationQ@$AppLoadedPackages,
  $AppLoadedPackages=<||>
  ];
AppNeeds[appName_,pkgName_String]:=
  If[!Lookup[$AppLoadedPackages,Key@{appName,pkgName},False],
    $AppLoadedPackages[{appName,pkgName}]=True;
    AppGet[appName,pkgName];
    ];
AppNeeds[appName_,Optional[Automatic,Automatic]]:=
  AppNeeds[appName,FileBaseName@NotebookFileName[]];
AppNeeds[Optional[Automatic,Automatic]]:=
  With[{app=FileNameTake[NotebookFileName[],{FileNameDepth@$AppDirectory+1}]},
    AppNeeds[app,Automatic]
    ];


(* ::Subsubsection::Closed:: *)
(*AppFromFile*)



AppFromFile[f_String]:=
  With[{
    splitPath=FileNameSplit[DirectoryName[ExpandFileName@f]]
    },
    Replace[
      SelectFirst[Range[Length@splitPath,1,-1],
        FileExistsQ@FileNameJoin@Append[Take[splitPath,#], "PacletInfo.m"]&,
        Which[
          StringMatchQ[ExpandFileName@f,$AppDirectory~~__],
            FileNameTake[
              FileNameDrop[f,FileNameDepth@$AppDirectory],
              1
              ],
          StringMatchQ[f,"http*"~~"/"~~WordCharacter..],
            URLParse[f]["Path"]//Last,
          MemberQ[FileNameTake/@AppNames["*", False], f],
            f,
          Length@PacletManager`PacletFind[f]>0,  
            PacletManager`PacletFind[f][[1]]["Location"]//FileBaseName,
          True,
            $Failed
          ]
        ],
      i_Integer:>
        splitPath[[i]]
      ]
    ];
AppFromFile[nb_NotebookObject]:=
  Replace[Quiet@NotebookFileName[nb],
    s_String:>
      AppFromFile[s]
    ];
AppFromFile[Optional[Automatic,Automatic]]:=
  AppFromFile@InputNotebook[];


(* ::Subsubsection::Closed:: *)
(*AppPackageOpen*)



AppPackageOpen[app_:Automatic,pkg_]:=
  Replace[AppPackage[app,pkg<>".m"],{
    f_String?FileExistsQ:>
      SystemOpen@f,
    _->$Failed
    }];
AppPackageOpen[Optional[Automatic,Automatic]]:=
  Replace[Quiet@NotebookFileName[],
    f_String:>
      AppPackageOpen[Automatic,
        FileBaseName@f
        ]
    ]


(* ::Subsubsection::Closed:: *)
(*AppPackagePullDeclarationsAction*)



AppPackagePullDeclarationsAction//Clear
AppPackagePullDeclarationsAction[
  Hold[
    _Begin|_BeginPackage|
      CompoundExpression[_Begin|_BeginPackage,___]
    ]
  ]:=
  Throw[Begin];
AppPackagePullDeclarationsAction[e:Except[Hold[Expression]]]:=
  Sow@e;


AppPackagePackagePullDeclarations[
  pkgFile_,
  casePattern_
  ]:=
    Cases[
      Reap[
        With[{f=OpenRead[pkgFile]},
          CheckAbort[
            Catch@
              Do[
                If[
                  Length[
                    ReadList[
                      f,
                      AppPackagePullDeclarationsAction@Hold[Expression],
                      1
                      ]
                    ]===0,
                    Throw[EndOfFile]
                  ],
                Infinity
                ];
            Close[f],
            Close[f]
            ]
          ]
        ][[2,1]],
      casePattern,
      Infinity
      ]


(* ::Subsubsection::Closed:: *)
(*AppPackageFunctions*)



AppPackageFunctions[app:_String, pkgFile_String?FileExistsQ]:=
  With[{
    cont=
      StringTrim[app, "`"]<>"`"
    },
    Block[{
      pkgFuncCheckedCache=<||>,
      $Context=
        cont<>"Private`",
      $ContextPath=
        Join[
          Replace[
            ToExpression[cont<>"PackageScope`Private`$PackageContexts"],
            Except[{__String}]->{}
            ],
          {
            cont,
            "System`"
            }
          ]
      },
      AppPackagePackagePullDeclarations[
        pkgFile,
        s_Symbol?(
          Function[sym,
            Not@KeyMemberQ[pkgFuncCheckedCache,Hold[sym]]&&
              With[
                {
                  v=
                    If[cont===None,
                      !StringMatchQ[
                        Quiet[Context[sym]],
                        "System`"|("*`*Private*")
                        ],
                      With[{pcont=Quiet[Context[sym]]},
                        StringMatchQ[pcont, cont<>"*"]&&
                          !StringContainsQ[pcont,"Private`"]  
                        ]
                      ]
                  },
                pkgFuncCheckedCache[Hold[sym]]=v
                ],
            HoldFirst
            ]
            ):>
            ToString[Unevaluated[s]]
        ]
      ]
    ];
AppPackageFunctions[
  app_String,
  path_String
  ]:=
  With[{pkg=AppPackage[app, StringTrim[path,".m"]<>".m"]},
    AppPackageFunctions[app, pkg]/;FileExistsQ[pkg]
    ];
AppPackageFunctions[app_, paths:{__String}]:=
  AssociationMap[
    AppPackageFunctions[app,#]&,
    paths
    ];
AppPackageFunctions[app_String]:=
  AppPackageFunctions[app, AppPackages[app]]


(* ::Subsubsection::Closed:: *)
(*AppFunctionPackage*)



AppFunctionPackage//Clear


AppFunctionPackage[app_:Automatic,f:{__String}]:=
  With[{funcs=AppPackageFunctions[app]},
    AssociationMap[
      Replace[Keys@Select[funcs,MemberQ[#]],{
        {}->None,
        {p_}:>p
        }]&,
      f
      ]
    ];
AppFunctionPackage[app_:Automatic,f_String]:=
  First@AppFunctionPackage[{f}];
AppFunctionPackage[app_:Automatic,f:{(_Symbol|_String)..}]:=
  AppFunctionPackage[
    Replace[app,
      Automatic:>
        FirstCase[Hold@f,s_Symbol:>StringTrim[Context[s],"`"],"System`",{2}]
      ],
    First/@
      Replace[
        Thread[Hold[f]],
        Hold[s_Symbol]:>Hold[SymbolName[Unevaluated@s]],
        1]//Evaluate
    ];
AppFunctionPackage[app_:Automatic,f_Symbol]:=
  AppFunctionPackage[
    Replace[app,
      Automatic:>StringTrim[Context[f],"`"]
      ],
    SymbolName[Unevaluated@f]
    ];
AppFunctionPackage[app_:Automatic,f:{__HoldPattern}]:=
  Replace[Thread[f,HoldPattern],
    Verbatim[HoldPattern][s_]:>
      AppFunctionPackage[app,s]
    ];
AppFunctionPackage[app_:Automatic,e_]/;!TrueQ[AppFunctionPackage$recurseProtect]:=
  Block[{AppFunctionPackage$recurseProtect=True},
    AppFunctionPackage[app,Evaluate[e]]
    ];
AppFunctionPackage~SetAttributes~HoldAll


(* ::Subsubsection::Closed:: *)
(*AppFunctionDependencies*)



(* ::Subsubsubsection::Closed:: *)
(*functionCallChain*)



functionCallChain[conts_,function_]:=
  With[{cpats=Alternatives@@Map[#<>"*"&,conts]},
    HoldPattern@@@
      FixedPoint[
        Union[#,
          Cases[
            Flatten@
              (Through[
                Map[Apply, {DownValues,UpValues,OwnValues,SubValues}]@#
                ]&/@#),
            s_Symbol?(
              Function[Null,
                Quiet[
                  StringMatchQ[Context[#],cpats]&&
                  Length[
                    Flatten@
                      Through[
                        Map[Apply,
                          {DownValues, UpValues, OwnValues, SubValues}
                          ]@Hold[#]
                        ]
                    ]>0
                  ],
                HoldFirst
                ]
              ):>Hold[s],
            \[Infinity],
            Heads->True
            ]
          ]&,
        Flatten@List@Thread@Hold[function],
        50
        ]
    ];
functionCallChain~SetAttributes~HoldRest


(* ::Subsubsubsection::Closed:: *)
(*AppFunctionDependencies*)



AppFunctionDependencies//ClearAll


AppFunctionDependencies[app_, function:_Symbol|{__Symbol}]:=
  With[{conts=
    {# ,#<>"Private`"}&@
      Quiet@
        Extract[Flatten@List@Thread@Hold[function], {1,1}, Context]
    },
    Replace[
      AppFunctionPackage[
        app,
        Select[
          functionCallChain[conts, function],
          With[{c=Alternatives@@conts},
            Quiet[
              With[{cont=Context@@#},
                StringStartsQ[cont, c]&&
                  StringFreeQ[cont, "`Private`"|"`PackagePrivate`"]
                ]
              ]&
            ]
          ]
        ],
    {
      a_Association:>
        GroupBy[First->Last]@
          KeyValueMap[Thread[#2->#]&,a],
      _:>
        <||>
      }]
    ];
AppFunctionDependencies[app_, Hold[function_Symbol]]:=
  AppFunctionDependencies[app, function];
AppFunctionDependencies[app_, functions:{Hold[_Symbol]..}]:=
  Replace[Thread[functions, Hold],
    Hold[s_]:>AppFunctionDependencies[app, s]
    ];
AppFunctionDependencies[app_:Automatic,f_]/;
  !TrueQ[AppFunctionDependencies$recurseProtect]:=
  Block[{AppFunctionDependencies$recurseProtect=True},
    AppFunctionDependencies[app,Evaluate[f]]
    ];
AppFunctionDependencies~SetAttributes~HoldAll


(* ::Subsubsection::Closed:: *)
(*AppPackageDependencies*)



(* ::Text:: *)
(*Need better dependency loading*)



AppPackageDependencies[app_, pkg:_String|{__String}]:=
  (
    AppNeeds[app, #]&/@AppPackages[app];
    AppFunctionDependencies[
      app,
      ToExpression[
        Names[
          app<>"`*`"<>#&/@
            Flatten@Apply[List, AppPackageFunctions[app, pkg]]
          ],
        StandardForm,
        Function[
          Null,
          If[Length@Flatten@
                Through[
                  Map[Apply, {DownValues,UpValues,OwnValues,SubValues}]@
                    Hold[#]
                  ]==0,
            Nothing,
            Hold@#
            ],
          HoldFirst
          ]
        ]
      ]
    );
AppPackageDependencies[app_:Automatic, f_Symbol]:=
  AppPackageDependencies[
    Replace[app,
      Automatic:>
        StringSplit[Context[f], "`"][[1]]
      ],
    AppFunctionPackage[app, f]
    ];
AppPackageDependencies[app_]:=
  AppPackageDependencies[app, AppPackages[app]]


(* ::Subsubsection::Closed:: *)
(*AppGenerateTestingNotebook*)



AppGenerateTestingNotebook[app_]:=
  Notebook[{
    Cell[app<>" Testing","CodeChapter"],
    Cell[BoxData@RowBox@{"<<",app<>"`"},"CodeInput"],
    MapIndexed[
      Cell[
        CellGroupData[Flatten@{
          Cell[First@#,"Section"],
          Cell[BoxData@RowBox@{
              "AppGet","[","\""<>app<>"\"",",",
              "\""<>First@#<>"\"","]"
              },
            "CodeInput"
            ]
          },
          If[First@#2==1,Open,Closed]
          ]
        ]&,
      Normal@AppPackageFunctions[app]
      ]
    },
    StyleDefinitions->
      FrontEnd`FileName[Evaluate@{$PackageName},"CodeNotebook.nb"]
    ];
AppGenerateTestingNotebook[Optional[Automatic,Automatic]]:=
  AppGenerateTestingNotebook[AppFromFile[]]


(* ::Subsection:: *)
(*ZIP dist*)



$AppCloudExtension="applications";
$AppBackupDirectoryName="_appcache"


(* ::Subsubsection::Closed:: *)
(*AppInstall*)



AppInstall[
    name_String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..]),
    loadFE_:Automatic]:=
  With[{},
    If[!DirectoryQ@AppDirectory@name,AppDownload@name];
    If[Replace[loadFE,
      Automatic:>(FileNames["*",{
        AppDirectory[name,"Palettes"],
        AppDirectory[name,"StyleSheets"]}
        ]=!={})
      ],
      DialogInput[Column@{
"Front end must quit to complete installation. 
Would you like to do that now?",
        Row@{
          DefaultButton["Quit Now",
            FrontEndTokenExecute@"FrontEndQuit"],
          Button["Wait",
            DialogReturn[]]
          }
        },
        WindowTitle->"Quit Mathematica"
        ];
      ];
    Get@FileNameJoin@{$UserBaseDirectory,"Applications",name,"Kernel","init.m"};
  ];


AppInstall[try___]:=
  With[{result=AppDownload[try]},
    Replace[result,{
      _AppDownload:>$Failed,
      f_:>If[DirectoryQ@AppDirectory@FileNameTake@f,
          AppInstall@f
          ];
      }]
    ]


(* ::Subsubsection::Closed:: *)
(*AppDownload*)



Options[AppDownload]:=
  Options@DownloadFile;
AppDownload[
    file:File[_String?DirectoryQ]|_String?DirectoryQ,
    name:(
        _String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
        Automatic
        ):Automatic,
    root:File[_String?DirectoryQ]|_String?DirectoryQ|Automatic:Automatic,
    ops:OptionsPattern[]
    ]:=
  With[{appName=StringReplace[
    FileBaseName@file,{
      Whitespace->"",
      Except[WordCharacter|DigitCharacter]->"$"
      }]},
      Block[{$BackupDirectoryName=$AppBackupDirectoryName},
        BackupCopyFile[file,name,Replace[root,Automatic:>$AppDirectory],ops]
        ]
      ];


AppDownload[
    file:(
        File[_String?(FileExtension@#==="zip"&)]|
        _String?(FileExtension@#==="zip"&)
        ),
    name:(
        _String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
        Automatic
        ):Automatic,
    root:File[_String?DirectoryQ]|_String?DirectoryQ|Automatic:Automatic,
    ops:OptionsPattern[]
    ]:=
  Block[{$BackupDirectoryName=$AppBackupDirectoryName},
    DownloadFile[file,name,Replace[root,Automatic:>$AppDirectory],ops]
    ];


AppDownload[
    file:(_CloudObject|_URL|_String),
    name:(
        _String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
        Automatic
        ):Automatic,
    root:File[_String?DirectoryQ]|_String?DirectoryQ|Automatic:Automatic,
    ops:OptionsPattern[]
    ]:=
  Block[{$BackupDirectoryName=$AppBackupDirectoryName},
    DownloadFile[
      Replace[file,_String:>
        Switch[
          OptionValue@"DownloadFrom",
          CloudObject,
            URLBuild@{$AppCloudExtension,file},
          "Google Drive",
            FileNameJoin@{$AppDirectoryName,file}
          ]
        ],
      name,
      Replace[root,Automatic:>$AppDirectory],
      ops]
    ];


AppDownload[
  file_,
  name:(
        _String?(StringMatchQ[Except[WhitespaceCharacter|"/"|"_"|"."]..])|
        Automatic
        ):Automatic,
  root:File[_String?DirectoryQ]|_String?DirectoryQ,
  source:Except[_Rule],
  ops:OptionsPattern[]
  ]:=
  AppDownload[file,name,root,"DownloadFrom"->source,ops];


(* ::Subsubsection::Closed:: *)
(*AppBundle*)



Options[AppBundle]:=
  Join[
    Options@CreateSyncBundle,{
    "BundleInfo"->Automatic
    }];
AppBundle[
  paths:_String|{__String},
  exportDir:_String?DirectoryQ|Automatic:Automatic,
  metadata:{(_Rule|_RuleDelayed)..}|_Assocation:{},
  ops:OptionsPattern[]]:=
  Replace[OptionValue["BundleInfo"],{
    Automatic:>
      AppBundle[paths,exportDir,metadata,
        "BundleInfo"->
          Replace[
            AppPath[First@Flatten@{paths},
              "Config","BundleInfo.m"],
            Except[_String?FileExistsQ]:>
              AppPath[First@Flatten@{paths},
                "Config","BundleInfo.wl"]
            ],
        ops
        ],
    f:(_String|_File)?FileExistsQ|_URL:>
      AppBundle[paths,exportDir,metadata,
        "BundleInfo"->None,
        Replace[Import[f],{
          o:{__?OptionQ}:>
            (Sequence@@FilterRules[o,Options@AppBundle]),
          _:>(Sequence@@{})
          }],
        ops
        ],
    _:>
      bundleApp[paths,exportDir,metadata,ops]
    }];
Options[bundleApp]=
  Options@AppBundle;
bundleApp[paths_,
  exportDir:_String?DirectoryQ|Automatic:Automatic,
  metadata:{(_Rule|_RuleDelayed)..}|_Assocation:{},
  ops:OptionsPattern[]]:=
  With[{bundle=
    CreateSyncBundle[
      Table[If[!FileExistsQ@app,AppDirectory@app,app],{app,Flatten@{paths}}],
      metadata,
      FilterRules[{
        ops,
        Directory->
          Automatic,
        Root->
          If[!FileExistsQ@First@Flatten@{paths},
            AppDirectory@First@Flatten@{paths},
            $AppDirectory
            ]
        },
        Options@CreateSyncBundle
        ]
      ]},
    If[exportDir=!=Automatic,
      RenameFile[bundle,FileNameJoin@{exportDir,FileNameTake@bundle}],
      bundle
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*AppUpload*)



(* ::CodeInput::Plain:: *)
Options[AppUpload]:=
  Join[
    Options@AppBundle,
    Options@UploadFile,
    {
      Directory->Automatic
      }
    ];
AppUpload[
  appName_String,
  ops:OptionsPattern[]]:=
  With[{dir=
    Block[{
      $AppDirectoryRoot=
        Replace[
          OptionValue@Directory,
          Except[_String?DirectoryQ]:>
            $AppDirectoryRoot
          ]},
      If[!FileExistsQ@appName,AppDirectory@appName,appName]
      ]},
    UploadFile[
      If[FileExistsQ@appName,
        appName,
        AppBundle[appName,
          FilterRules[{ops},Options@AppBundle]]
        ],
      $AppCloudExtension,
      ops
      ]
    ];


AppUpload[
  appName_,
  sourceLink:"Google Drive"|CloudObject|Automatic,
  ops:OptionsPattern[]
  ]:=
  AppUpload[appName,
    "UploadTo"->sourceLink,
    ops]


(* ::Subsubsection::Closed:: *)
(*AppBackup*)



AppBackup[appName_]:=
  With[{
    appDir=AppDirectory[appName]
    },
    BackupFile[appDir,$AppDirectory,$AppBackupDirectoryName]
    ];  


(* ::Subsubsection::Closed:: *)
(*AppIndex*)



AppIndex[]:=Table[
{"Name","LastModified"}/.First@CloudObjectInformation@o,
{o,CloudObjects@CloudObject["applications"]}
];


(* ::Subsubsection::Closed:: *)
(*AppBackups*)



AppBackups[appName_:""]:=
  FileBackups[appName,AppDirectory@$AppBackupDirectoryName];


(* ::Subsubsection::Closed:: *)
(*AppRestore*)



AppRestore[appName_]:=
  RestoreFile[
    appName,
    AppDirectory@$AppBackupDirectoryName,
    $AppDirectory
    ];


(* ::Subsection:: *)
(*Project Dist*)



$AppProjectExtension="project";
$AppProjectImages="img";
$AppProjectCSS="css";


(* ::Subsubsection::Closed:: *)
(*Readme*)



Options[AppDeployReadme]=
  {
    "UploadTo"->"Paclet"
    };
AppDeployReadme[appName_,ops:OptionsPattern[]]:=
  With[{app=AppFromFile[appName]},
    If[FileExistsQ@AppPath[app,"README.md"],
      Replace[OptionValue["UploadTo"],{
        "Paclet":>
          XMLDeploy[
            MarkdownGenerate[AppPath[app,"README.md"]],
            URLBuild@{AppPacletSiteURL[app],"README"},
            Permissions->"Public"
            ],
        CloudObject[o_,___]:>
          XMLDeploy[
            MarkdownGenerate[AppPath[app,"README.md"]],
            URLBuild@{o,"README"},
            Permissions->"Public"
            ],
        d_String?DirectoryQ:>
          XMLExport[
            MarkdownGenerate[AppPath[app,"README.md"]],
            FileNameJoin@{d,"README.html"}
            ],
        d_String?SyncPathQ:>
          XMLExport[
            MarkdownGenerate[AppPath[app,"README.md"]],
            FileNameJoin@{SyncPath[d],"README.html"}
            ]
        }
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*Imgs*)



Options[AppDeployImages]=
  {
    "UploadTo"->"Paclet"
    };
AppDeployImages[appName_,ops:OptionsPattern[]]:=
  With[{app=AppFromFile[appName]},
    With[{imgFiles=
      FileNames["*."~~
        Alternatives@@ToLowerCase@Image`$ExportImageFormats,
        AppPath[app,$AppProjectExtension,$AppProjectImages]
        ]
      },
      If[Length@imgFiles>0,
        Replace[OptionValue["UploadTo"],{
          "Paclet":>
            Map[
              CopyFile[File[#],
                CloudObject[
                  URLBuild@{
                    AppPacletSiteURL[app],
                    $AppProjectExtension,$AppProjectImages,
                    FileNameTake[#]
                    },
                  Permissions->"Public"
                  ]
                ]&,
              imgFiles
              ],
          CloudObject[o_,___]:>
            Map[
              CopyFile[File[#],
                CloudObject[
                  URLBuild@{
                    o,
                    $AppProjectExtension,$AppProjectImages,
                    FileNameTake[#]
                    },
                  Permissions->"Public"
                  ]
                ]&,
              imgFiles
              ],
          d_String?DirectoryQ:>
            Map[
              CopyFile[
                #,
                FileNameJoin@{
                  d,
                  $AppProjectExtension,$AppProjectImages,
                  FileNameTake[#]
                  }
                ]&,
              imgFiles
              ],
          d_String?SyncPathQ:>
            Map[
              CopyFile[
                #,
                FileNameJoin@{
                  SyncPath[d],
                  $AppProjectExtension,
                  $AppProjectImages,
                  FileNameTake[#]
                  }
                ]&,
              imgFiles
              ]
          }
          ]
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*CSS*)



Options[AppDeployCSS]=
  {
    "UploadTo"->"Paclet"
    };
AppDeployCSS[appName_,ops:OptionsPattern[]]:=
  With[{app=AppFromFile[appName]},
    With[{cssFiles=
      FileNames["*.css",
        AppPath[app,$AppProjectExtension,$AppProjectCSS]
        ]
      },
      If[Length@cssFiles>0,
        Replace[OptionValue["UploadTo"],{
          "Paclet":>
            Map[
              CopyFile[File[#],
                CloudObject[
                  URLBuild@{
                    AppPacletSiteURL[app],
                    $AppProjectExtension,$AppProjectCSS,
                    FileNameTake[#]
                    },
                  Permissions->"Public"
                  ]
                ]&,
              cssFiles
              ],
          CloudObject[o_,___]:>
            Map[
              CopyFile[File[#],
                CloudObject[
                  URLBuild@{
                    o,
                    $AppProjectExtension,$AppProjectCSS,
                    FileNameTake[#]
                    },
                  Permissions->"Public"
                  ]
                ]&,
              cssFiles
              ],
          d_String?DirectoryQ:>
            Map[
              CopyFile[
                #,
                FileNameJoin@{
                  d,
                  $AppProjectExtension,$AppProjectCSS,
                  FileNameTake[#]
                  }
                ]&,
              cssFiles
              ],
          d_String?SyncPathQ:>
            Map[
              CopyFile[
                #,
                FileNameJoin@{
                  SyncPath[d],
                  $AppProjectExtension,
                  $AppProjectCSS,
                  FileNameTake[#]
                  }
                ]&,
              cssFiles
              ]
          }
          ]
        ]
      ]
    ];


(* ::Subsubsection::Closed:: *)
(*HTML*)



Options[AppDeployHTML]=
  {
    "UploadTo"->"Paclet"
    };
AppDeployHTML[appName_,ops:OptionsPattern[]]:=
  With[{app=AppFromFile[appName]},
    With[{htmlFiles=
      FileNames["*.html",
        AppPath[app,$AppProjectExtension]
        ]
      },
      If[Length@htmlFiles>0,
        Replace[OptionValue["UploadTo"],{
          "Paclet":>
            Map[
              CopyFile[File[#],
                CloudObject[
                  URLBuild@{
                    AppPacletSiteURL[app],
                    $AppProjectExtension,
                    FileNameTake[#]
                    },
                  Permissions->"Public"
                  ]
                ]&,
              htmlFiles
              ],
          CloudObject[o_,___]:>
            Map[
              CopyFile[File[#],
                CloudObject[
                  URLBuild@{
                    o,
                    $AppProjectExtension,
                    FileNameTake[#]
                    },
                  Permissions->"Public"
                  ]
                ]&,
              htmlFiles
              ],
          d_String?DirectoryQ:>
            Map[
              CopyFile[
                #,
                FileNameJoin@{
                  d,
                  $AppProjectExtension,
                  FileNameTake[#]
                  }
                ]&,
              htmlFiles
              ],
          d_String?SyncPathQ:>
            Map[
              CopyFile[
                #,
                FileNameJoin@{
                  SyncPath[d],
                  $AppProjectExtension,
                  FileNameTake[#]
                  }
                ]&,
              htmlFiles
              ]
          }
          ]
        ]
      ]
    ];


End[];



