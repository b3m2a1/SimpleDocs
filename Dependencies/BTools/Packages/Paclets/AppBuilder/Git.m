(* ::Package:: *)

(* Autogenerated Package *)

(* ::Text:: *)
(*Internal Git cruft that\[CloseCurlyQuote]s been pushed to a lower-context*)



(* ::Subsubsection::Closed:: *)
(*Git*)



AppGitInit::usage=
	"Configures a Git repository for the app";
AppGitClone::usage=
	"Clones a Git repo";
AppGitCommit::usage=
	"Configures pushes to the git repo";
AppGitSafeCommit::usage=
	"Commits, making sure the ignore and exclude exist";
AppGitHubConfigure::usage=
	"Configures the app to be able to push to github";
AppGitHubRepo::usage=
	"The GitHub repo for the app";
AppGitHubSetRemote::usage=
	"Sets the remote for the app";
AppGitRealignRemotes::usage=
	"Makes sure git will work across remotes";
AppGitHubPull::usage=
	"Pulls the app from its master branch";
AppGitHubPush::usage=
	"Pushes the app to its master branch";
AppGitHubDelete::usage=
	"Removes a repo from github";
AppGitHubCreateRelease::usage=
	"Creates a release on GitHub";


Begin["`Private`"];


(* ::Subsection:: *)
(*Git*)



(* ::Subsubsection::Closed:: *)
(*GitInit*)



AppGitInit[appName_:Automatic]:=
	With[{app=AppFromFile[appName]},
		With[{d=AppDirectory[app]},
			GitInit[d];
			AppRegenerateGitExclude[app];
			AppRegenerateGitIgnore[app];
			d
			]
		];


(* ::Subsubsection::Closed:: *)
(*RegenerateGitIgnore*)



AppRegenerateGitIgnore[appName_:Automatic,
	patterns:_String|{__String}:
		{
			"Packages/*.nb",
			"Packages/*/*.nb",
			"Packages/*/*/*/*.nb",
			".DS_Store"
			}]:=
	With[{
		app=
			AppFromFile[appName]
			},
		If[GitRepoQ@AppDirectory[app],
			With[{f=OpenWrite[AppPath[app,".gitignore"]]},
				WriteLine[f,
					StringJoin@Riffle[Flatten@{patterns},"\n"]
					];
				Close@f
				],
			$Failed
			]
		];


 (* ::Subsubsection::Closed:: *)
(*RegenerateGitExclude*)



AppRegenerateGitExclude[appName_:Automatic,
	patterns:_String|{__String}:{"Private/*"}]:=
	With[{
		app=
			AppFromFile[appName]
			},
		If[GitRepoQ@AppDirectory[app],
			If[Not@DirectoryQ@AppDirectory[app,".git","info"],
				CreateDirectory[AppDirectory[app,".git","info"]]
				];
			With[{f=OpenWrite[AppPath[app,".git","info","exclude"]]},
				WriteLine[f,
					StringJoin@Riffle[Flatten@{patterns},"\n"]
					];
				Close@f
				],
			$Failed
			]
		];


(* ::Subsubsection::Closed:: *)
(*RegenerateReadme*)



appREADMETemplate:=
	StringReplace[
		Import[
			PackageAppPath["Resources", "Templates", "README.md"],
			"Text"
			],{
		"`"->"`tick`",
		"$"~~l:LetterCharacter..~~"$":>"`"<>l<>"`"
		}]


Options[AppRegenerateReadme]={
	"Header"->"",
	"Footer"->""
	};
AppRegenerateReadme[appName:_String|Automatic:Automatic]:=
	With[{app=AppFromFile[appName]},
		GitHubCreateReadme[
			AppDirectory[app],
			TemplateApply[appREADMETemplate,<|
				"tick"->"`",
				"Name"->
					app,
				"FunctionCount"->
					(
						Needs[app<>"`"];
						Length@Names[app<>"`*"]
						),
				"PackageCount"->
					Length@AppPackages[app],
				"SymbolPages"->
					Replace[Length@AppSymbolPages[app],{
						0->
							"no ref pages",
						1->
							"1 ref page",
						n_:>
							ToString[n]<>" ref pages"
						}],
				"GuidePages"->
					Replace[Length@AppGuides[app],{
						0->
							"no guide pages",
						1->
							"1 guide page",
						n_:>
							ToString[n]<>" guide pages"
						}],
				"TutorialPages"->
					Replace[Length@AppTutorials[app],{
						0->
							"no tutorial pages",
						1->
							"1 tutorial page",
						n_:>
							ToString[n]<>" tutorial pages"
						}],
				"Stylesheets"->
					Replace[Length@AppStyleSheets[app],{
						0->
							"no stylesheets",
						1->
							"1 stylesheet",
						n_:>
							ToString[n]<>" stylesheet"
						}],
				"Palettes"->
					Replace[Length@AppPalettes[app],{
						0->
							"no palettes",
						1->
							"1 palette",
						n_:>
							ToString[n]<>" palettes"
						}],
				"Installer":>
					AppPacletInstallerURL@app,
				"Uninstaller":>
					AppPacletUninstallerURL@app
				|>]
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitClone*)



AppGitClone[base_String]:=
	With[{
		url=
			If[StringMatchQ@MatchQ[base,"http*"],
				base,
				GitHubRepo[base]
				],
		app=
			AppFromFile[base]
		},
		GitClone[url,
			AppDirectory[app]
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitCommit*)



AppGitCommit[
	appName:_String|Automatic:Automatic,
	message:_String|Automatic:Automatic,
	add:True|False:True
	]:=
	Replace[AppFromFile[appName],
		app_String:>
			With[{d=AppDirectory[app]},
				If[add,GitAdd[d,"-A"]];
				GitCommit[d,
					"Message"->
						Replace[message,
							Automatic:>
								TemplateApply[
									"Committed `` application @ ``",
									{
										app,
										StringReplace[
											DateString["ISODateTime"],
											"T"->"_"
											]}
									]
							]
					]
				]
		];


AppGitSafeCommit[
	appName:_String|Automatic:Automatic,
	message:_String|Automatic:Automatic,
	add:True|False:True
	]:=
	With[{app=AppFromFile[appName]},
		If[!FileExistsQ@AppPath[app,".gitignore"],	
			AppRegenerateGitIgnore[]
			];
		If[!FileExistsQ@AppPath[app,".git","info","exclude"],	
			AppRegenerateGitExclude[]
			];
		AppGitCommit[app,message,add]
		]


(* ::Subsubsection::Closed:: *)
(*GitHubRepo*)



$AppGitHubPrefix="";
	(*"mathematica-";*)


AppGitHubRepo[appName_, password_:None]:=
	Replace[
		AppFromFile[appName],
		s_String:>
			With[{u=Git["GetRemoteURL", AppPath[s]]},
				If[URLParse[u, "Domain"]=!="github.com",
					URL@
						GitHubPath[
							$AppGitHubPrefix<>s,
							"Password"->password
							],
					u
					]
				]
		];


(* ::Subsubsection::Closed:: *)
(*AppGitHubSetRemote*)



AppGitHubSetRemote[appName_,remote_:Automatic]:=
	With[{app=AppFromFile[appName]},
		Replace[Replace[remote,Except[_String]:>AppGitHubRepo[appName]],
			r_String:>
				(*Quiet@*)
					Check[
						Git["AddRemote", 
							AppPath[app],
							r
							],
						Git["RemoveRemote", AppPath[app],
							r
							];
						Git["AddRemote", 
							AppPath[app],
							r
							]
						]
			]
		]


(* ::Subsubsection::Closed:: *)
(*AppGitRealignRemotes*)



AppGitRealignRemotes[appName_]:=
	With[{
		app=AppFromFile[appName]
		},
		If[Git["ListRemotes", AppPath[app]]===Null,
			AppGitHubSetRemote[AppDirectory[app]]
			];
		Git["Fetch", AppPath[app]];
		Git["Reset", AppPath[app], "origin/master"];
		Git["Checkout", AppPath[app], "origin/master"];
		];


(* ::Subsubsection::Closed:: *)
(*GitHubConfigure*)



AppGitHubConfigure[appName_:Automatic]:=
	Catch@
		Module[{app=AppFromFile[appName],repo,repoExistsQ},
			repo=AppGitHubRepo[app];
			If[repo===$Failed,
				Throw[$Failed]
				];
			If[!GitRepoQ@AppDirectory[app],
				AppGitInit[app];
				AppGitHubSetRemote[app, repo];
				repoExistsQ=Between[URLRead[repo,"StatusCode"],{200,299}];
				If[repoExistsQ,
					AppGitRealignRemotes[app]
					]
				];
			If[Git["RepoQ", AppDirectory[app]],
				If[!ValueQ[repoExistsQ],
					repoExistsQ=Between[URLRead[repo, "StatusCode"],{200,299}]
					];
				If[!repoExistsQ,
					GitHub["Create", $AppGitHubPrefix<>app, "ImportedResult"];
					AppGitHubSetRemote[app,repo]
					];
				repo
				]
			];


(* ::Subsubsection::Closed:: *)
(*GitHubPush*)



AppGitHubPush[appName_:Automatic]:=
	With[{app=AppFromFile[appName]},
		If[GitRepoQ@AppDirectory[app],
			Git["PullOrigin", AppPath@app];
			Block[{$GitHubEncodePassword=True},
				GitHub["Push", AppDirectory[app]]
				]
			]
		];


(* ::Subsubsection::Closed:: *)
(*GitHubDelete*)



AppGitHubDelete[appName_]:=
	With[{app=AppFromFile[appName]},
		If[GitRepoQ@AppPath[app],
			With[{r=AppGitHubRepo[app]},
				With[{res=GitHub["Delete", URLParse[r, "Path"][[-1]]]},
					If[res["StatusCode"]<400,
						Git["RemoveRemote", AppPath[app], r];
						Success["Removed", Prepend[res, "Repository"->r]],
						Failure["NotRemoved", res]
						]
					]
				]
			]
		]


(* ::Subsubsection::Closed:: *)
(*GitHubCreateRelease*)



Options[AppGitHubCreateRelease]:=
	Options[AppGitHubCreateRelease]=
		Join[
			GitHub["CreateRelease", "Options"],
			{
				"SubmitPaclet"->True,
				"UseCachedPaclets"->True
				}
			];
AppGitHubCreateRelease[
	app_, 
	rname:_String|Automatic:Automatic, 
	ops:OptionsPattern[]
	]:=
	Module[
		{
			repo=URLBuild@Normal@GitHub["Path", AppGitHubRepo[app]],
			release,
			paclet,
			asset
			},
		release=
			GitHub["CreateRelease", 
				repo, 
				Replace[rname, 
					Automatic:>"v"<>AppPacletExecute["PacletInfo", app]["Version"]
					],
				ops,
				"ResultObject"
				];
		If[!FailureQ@release,
			If[OptionValue["SubmitPaclet"]//TrueQ,
				paclet=
					PacletExecute["FindPacletFile", app, 
						"BuildPaclets"->False,
						"UseCachedPaclets"->TrueQ@OptionValue["UseCachedPaclets"]
						];
				Which[
					TrueQ@paclet,
						paclet=PacletExecute["FindPacletFile", app],
					!(StringQ@paclet&&FileExistsQ@paclet),
						paclet=AppPacletExecute["Bundle", app]
					];
				asset=
					GitHub["UploadReleaseAsset",
						repo,
						release["ID"],
						paclet
						];
				];
			];
		release
		]


End[];



