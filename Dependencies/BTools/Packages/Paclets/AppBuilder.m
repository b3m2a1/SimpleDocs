(* ::Package:: *)

(* Autogenerated Package *)

(* ::Subsubsection::Closed:: *)
(*Execute*)



AppExecute::usage=
  "A high-level interface to low-level application manipulation procedures";


(* ::Subsubsection::Closed:: *)
(*DocGen*)



AppDocGen::usage=
  "A high-level interface to generating application docs";


(* ::Subsubsection::Closed:: *)
(*Git*)



AppGit::usage=
  "Git-type wrapper for apps";


(* ::Subsubsection::Closed:: *)
(*PacletExecute*)



AppPacletExecute::usage=
  "PacletExecute-type wrapper for apps";


Begin["`Private`"];


(* ::Subsection:: *)
(*Execute*)



(* ::Subsubsection::Closed:: *)
(*Methods*)



(* ::Subsubsubsection::Closed:: *)
(*$AppPathMethods*)



$AppPathMethods=
  <|
    "ListApplications"->
      (AppNames[]&),
    "Path"->
      AppPath,
    "MainDirectory"->
      ($AppDirectory&),
    "SetMainDirectory"->
      (Replace[#, s_String?DirectoryQ:>Set[$AppDirectory, s]]&),
    "DirectoryPath"->
      ($AppDirectories&),
    "GetAppName"->AppFromFile
    |>;


(* ::Subsubsubsection::Closed:: *)
(*$AppEditMethods*)



$AppEditMethods=
  <|
    "Configure"->
      AppConfigure,
    "ConfigureSubapp"->
      AppConfigureSubapp,
    "ReconfigureSubapp"->
      AppReconfigureSubapp,
    "FileNames"->
      AppFileNames,
    "ListContent"->
      AppComponentFiles,
    "FindFile"->
      AppFindFile,
    "AddContent"->
      AppAddContent,
    "AddDependency"->
      AppAddDependency,
    "UpdateDependencies"->
      AppUpdateDependencies,
    "ListPackages"->
      AppPackages,
    "ListStylesheets"->
      AppStyleSheets,
    "ListPalettes"->
      AppPalettes,
    "FindPackage"->
      AppPackage,
    "FindStylesheet"->
      AppStylesheet,
    "FindPalette"->
      AppPalette,
    "RegenerateConfig"->
      AppConfigRegenerate,
    "RegeneratePacletInfo"->
      AppRegeneratePacletInfo,
    "RegenerateLoaderFile"->
      AppRegenerateInit,
    "RegenerateDirectories"->
      AppRegenerateDirectories,
    "RegenerateContextLoaders"->
      AppRegenerateContextLoadFiles,
    "RegenerateLoadInfo"->
      AppRegenerateLoadInfo
    |>;


(* ::Subsubsubsection::Closed:: *)
(*Distribution*)



$AppDistMethods=
  <|
    "Publish"->
      AppPublish
    |>


(* ::Subsubsubsection::Closed:: *)
(*$AppDevMethods*)



$AppDevMethods=
  <|
    "Get"->AppGet,
    "Needs"->AppNeeds,
    "OpenPackage"->AppPackageOpen,
    "ListContexts"->AppContexts,
    "MainContext"->AppMainContext,
    "PackageFunctions"->AppPackageFunctions,
    "PackageDependencies"->AppPackageDependencies,
    "FunctionDependencies"->AppFunctionDependencies
    |>


(* ::Subsubsubsection::Closed:: *)
(*$AppExecuteMethods*)



$AppExecuteMethods=
  Join[
    $AppPathMethods,
    $AppEditMethods,
    $AppDistMethods,
    $AppDevMethods
    ];
$appNoAppMethods=
  {
    "Configure", "SetMainDirectory", 
    "MainDirectory", "DirectoryPath", 
    "GetAppName"
    };
validateAppExecCall[app_, meth_]:=
  StringQ@app||MatchQ[meth, Alternatives@@$appNoAppMethods];


(* ::Subsubsection::Closed:: *)
(*AppExecute*)



AppExecute//Clear
AppExecute[
  method_String?(KeyExistsQ[$AppExecuteMethods, #]&),
  app:_String,
  args___
  ]:=
  With[{a=AppFromFile[app], m=$AppExecuteMethods[method]},
    With[{res=m[If[StringQ@a, a, app], args]},
      res/;Head[res]=!=m
      ]/;validateAppExecCall[a, method]
    ];
AppExecute[
  method_String?(KeyExistsQ[$AppExecuteMethods, #]&),
  app:_PacletManager`Paclet,
  args___
  ]:=
  AppExecute[method, app["Location"], args];
AppExecute[
  method_String?(KeyExistsQ[$AppExecuteMethods, #]&),
  Optional["Function", "Function"]
  ]:=
  Replace[$AppExecuteMethods[method], f_Function:>f[]];
AppExecute[
  method_String?(KeyExistsQ[$AppExecuteMethods, #]&),
  "Options"
  ]:=
  Options@Evaluate[$AppExecuteMethods[method]];


(* ::Subsection:: *)
(*Docs*)



(* ::Subsubsection::Closed:: *)
(*AppDocGen*)



(* ::Subsubsubsection::Closed:: *)
(*$AppDocGenMethodRouter*)



(* ::Text:: *)
(*Use this to dispatch to all of the other App docs methods*)



$AppDocGenMethodRouter:=
  <|
    "SymbolPages"->
      <|
        Automatic->
          AppGenerateSymbolNotebook,
        "PackageNotebook"->
          AppGeneratePackageSymbolNotebook,
        "Template"->
          AppSymbolNotebook,
        "PackageTemplate"->
          AppPackageSymbolNotebook,
        "Save"->
          AppSaveSymbolPages,
        "PackageSave"->
          AppPackageSaveSymbolPages
        |>,
    "Guide"->
      <|
        Automatic->
          AppGuideNotebook,
        "Save"->
          AppSaveGuide,
        "Template"->
          AppGuideNotebook
        |>,
    "Tutorial"->
      <|
        Automatic->AppTutorialNotebook,
        "PackageTemplate"->AppPackageDocumentationTemplate
        |>,
    "Documentation"->
      <|
        Automatic->AppGenerateDocumentation,
        "Package"->AppPackageGenerateDocumentation,
        "Template"->AppDocumentationTemplate
        |>,
    "HTML"->
      <|
        Automatic->AppGenerateHTMLDocumentation,
        "Package"->AppPackageGenerateHTMLDocumentation
        |>,
    "Index"->
      AppIndexDocs
    |>;


(* ::Subsubsubsection::Closed:: *)
(*appDocGenDefault*)



AppDocGen::nopkg=
  "Method `` requires ";
appDocGenDefault[
  app_String, type_String, 
  fun_Symbol, method:_String|_Symbol, 
  methOps_?OptionQ, ops___?OptionQ
  ]:=
  Catch@
  With[
    {
      pkg=Lookup[methOps, "Package", None], 
      meth=ToString[method],
      dir=
        Lookup[methOps, Directory, Automatic],
      ext=
        Lookup[methOps, Extension, True],
      gtype=
        Lookup[methOps, "GenerateType", All],
      fnp=
        Lookup[methOps, "FileNamePattern", All]
      },
    If[StringStartsQ[meth, "Package"]&&!StringQ[pkg],
      Message[AppDocGen::nopkg, pkg];
      Throw@$Failed
      ];
    Which[
      fun===AppGenerateDocumentation||StringEndsQ[meth, "Save"],
        If[StringStartsQ[meth, "Package"],
          fun[app, pkg, dir, ext,
            Evaluate@FilterRules[{ops}, Options@fun]
            ],
          fun[app, dir, ext,
            Evaluate@FilterRules[{ops}, Options@fun]
            ]
          ],
      type==="Documentation",
        Which[
          StringStartsQ[meth, "Package"],
            fun[app, pkg, dir, gtype, fnp,
              Evaluate@FilterRules[{ops}, Options@fun]
              ],
          StringStartsQ[meth, "Template"],
            fun[app,
              Evaluate@FilterRules[{ops}, Options@fun]
              ],
          True,
            fun[app, dir, gtype, fnp,
              Evaluate@FilterRules[{ops}, Options@fun]
              ]
          ],
      StringStartsQ[meth, "Package"],
        fun[app, pkg, Evaluate@FilterRules[{ops}, Options@fun]],
      True,
        fun[app, Evaluate@FilterRules[{ops}, Options@fun]]
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*AppDocGen*)



AppDocGen//Clear


Options[AppDocGen]=
  {
    Method->Automatic
    };
AppDocGen[
  type:_String?(KeyExistsQ[$AppDocGenMethodRouter, #]&):"SymbolPage",
  app_?StringQ,
  ops:OptionsPattern[]
  ]:=
  Block[
    {
      $DocGenMethodRouter=$AppDocGenMethodRouter,
      $DocGenFunction=appDocGenDefault
      },
    DocGen[type, app, ops]
    ]
AppDocGen~SetAttributes~HoldRest


(* ::Subsection:: *)
(*Git*)



(* ::Subsubsection::Closed:: *)
(*Router*)



$AppGitRouter:=
  <|
    "Init"->
      AppGitInit,
    "Clone"->
      AppGitClone,
    "Commit"->
      AppGitSafeCommit,
    "GitHubRepo"->
      AppGitHubRepo,
    "GitHubConfigure"->
      AppGitHubConfigure,
    "GitHubPush"->
      AppGitHubPush,
    "GitHubDelete"->
      AppGitHubDelete,
    "GitHubCreateRelease"->
      AppGitHubCreateRelease
    |>


(* ::Subsubsection::Closed:: *)
(*Git*)



AppGit//Clear


AppGit[
  k_?(KeyExistsQ[$AppGitRouter, #]&),
  app_String,
  args___
  ]:=
  With[{fn=$AppGitRouter[k]},
    With[{res=fn[app, args]},
      res/;Head[res]=!=fn
      ]
    ];
AppGit[
  k_?(KeyExistsQ[$AppGitRouter, #]&),
  Optional["Function", "Function"]
  ]:=
  $AppGitRouter[k];
AppGit[
  k_?(KeyExistsQ[$AppGitRouter, #]&),
  "Options"
  ]:=
  Options@Evaluate@$AppGitRouter[k];


(* ::Subsection:: *)
(*Paclet Dist*)



(* ::Subsubsection::Closed:: *)
(*PacletExecute*)



$AppPacletExecuteMethods=
  <|
    "Paclet"->
      AppPaclet,
    "PacletInfo"->
      AppPacletInfo,
    "SiteURL"->
      AppPacletSiteURL,
    "BundleSite"->
      AppPacletSiteBundle,
    "Upload"->
      AppPacletUpload,
    "Bundle"->
      AppPacletBundle,
    "Backup"->
      AppPacletBackup,
    "UploadSubpaclet"->
      AppSubpacletUpload
    |>;


AppPacletExecute//Clear


AppPacletExecute[
  k_?(KeyExistsQ[$AppPacletExecuteMethods, #]&),
  app_String,
  args___
  ]:=
  With[{fn=$AppPacletExecuteMethods[k]},
    With[{res=fn[app, args]},
      res/;Head[res]=!=fn
      ]
    ];
AppPacletExecute[
  k_?(KeyExistsQ[$AppPacletExecuteMethods, #]&),
  Optional["Function", "Function"]
  ]:=
  $AppPacletExecuteMethods[k];
AppPacletExecute[
  k_?(KeyExistsQ[$AppPacletExecuteMethods, #]&),
  "Options"
  ]:=
  Options@Evaluate@$AppPacletExecuteMethods[k];


(* ::Subsection:: *)
(*FE Stuff*)



(* ::Subsubsection::Closed:: *)
(*Autocompletions*)



$AppNamesCurrent=AppNames["*", True];


(* ::Subsubsubsection::Closed:: *)
(*AppExecute*)



PackageAddAutocompletions@
  Map[
    #->
      {
        Keys@$AppExecuteMethods,
        Join[$AppNamesCurrent, {"Function", "Options"}]
        }&,
    {
      "AppExecute"
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*DocGen*)



PackageAddAutocompletions@
  Map[
    #->
      {
        Keys@$AppDocGenMethodRouter,
        Join[$AppNamesCurrent, {"Function", "Options"}]
        }&,
    {
      "AppDocGen"
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*PacletExecute*)



PackageAddAutocompletions@
  Map[
    #->
      {
        Keys@$AppPacletExecuteMethods,
        Join[$AppNamesCurrent, {"Function", "Options"}]
        }&,
    {
      "AppPacletExecute"
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*Git*)



PackageAddAutocompletions@
  Map[
    #->
      {
        Keys@$AppGitRouter,
        Join[$AppNamesCurrent, {"Function", "Options"}]
        }&,
    {
      "AppGit"
      }
    ]


End[];



